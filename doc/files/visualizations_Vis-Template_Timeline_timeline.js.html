<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>visualizations/Vis-Template/Timeline/timeline.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/EEXCESS.model.common.html">EEXCESS.model.common</a></li>
                                <li><a href="../classes/EEXCESS.model.constants.html">EEXCESS.model.constants</a></li>
                                <li><a href="../classes/EEXCESS.model.interests.html">EEXCESS.model.interests</a></li>
                                <li><a href="../classes/EEXCESS.model.languages.html">EEXCESS.model.languages</a></li>
                                <li><a href="../classes/EEXCESS.model.obfuscation.html">EEXCESS.model.obfuscation</a></li>
                                <li><a href="../classes/EEXCESS.model.policy.html">EEXCESS.model.policy</a></li>
                                <li><a href="../classes/EEXCESS.model.profile.html">EEXCESS.model.profile</a></li>
                                <li><a href="../classes/EEXCESS.model.storage.html">EEXCESS.model.storage</a></li>
                                <li><a href="../classes/EEXCESS.model.util-html.html">EEXCESS.model.util-html</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: visualizations/Vis-Template/Timeline/timeline.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

function Timeline( root, visTemplate ){
		
	/**
	 * Steps executed when the timeline is intialized
	 * 
	 * */
	var TIMEVIS = {};
	TIMEVIS.Settings = new Settings(&#x27;timeline&#x27;);

	var Vis = visTemplate;										// Allows calling template&#x27;s public functions
	Geometry = new Geometry();									// Ancillary functions for drawing purposes
	
	var width, focusHeight, focusMargin, contextHeight, contextMargin, centerOffset, verticalOffset;
	var xAxisChannel, yAxisChannel, colorChannel, data, keywords;	// data retrieved from Input() function
	var x, x2, y, y2, color;										// scales
	var xAxis, yAxis, xAxis2, yAxis2;								// axis functions
	var chart, focus, context;										// main graphic components
	var circles, flagLines,textInCircles;											// circles selector and flag
	var zoom, brush;												// behaviors
	var leftHandle, rightHandle;									// brush handles
	var leftHandleImg  = &quot;../../media/left-handle.png&quot;;
	var rightHandleImg = &quot;../../media/right-handle.png&quot;;
	var legendDomain;												// legend domain = color domain + selected attribute
	var fullExtent, currentExtent;									// extents used mainly for zooming and brushing
	var keywordNodes, keywordNodeData, kwNodes = [];				// input dataset for keyword nodes
	var selectedId;
	var delay = 400;
	
	/**
	 *  Define line function to connect nodes in focus area
	 */						
	var lineFunction = d3.svg.line()
			        	.x(function(d) { return (x(d.xValue) + d.xOffset); })
			        	.y(function(d) { return (y(d.yValue) + d.yOffset); })
			        	.interpolate(&quot;monotone&quot;);
	
	
	var getLegendDomain = function(colorDomain){
		
		var legendDomain = [];
		
		colorDomain.forEach(function(c, i){
			legendDomain[i] = { &#x27;item&#x27;: c, &#x27;selected&#x27;: false };
		});
		return legendDomain;
	};
	
	
	
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	TIMEVIS.Evt = {};


	/**
	 * Brush brushed and brushended
	 * */
	TIMEVIS.Evt.brushed = function() {
		var brushExtent = brush.extent();
		leftHandle.attr(&quot;x&quot;, x2(brushExtent[0]) - 12);
		rightHandle.attr(&quot;x&quot;, x2(brushExtent[1]) - 8);
		
		x.domain(brush.empty() ? x2.domain() : brushExtent);
		TIMEVIS.Render.redraw();

	};
	
	//experimental function
	TIMEVIS.Evt.filterListPerTime = function(minDateInYears,maxDateInYears){
		var indicesToHighlight = [];
		var currentYear = 0;
		data.forEach(function(d, i){
			if(d.hasOwnProperty(&quot;year&quot;)){	
				currentYear = d.year.getFullYear();
				if(minDateInYears &lt;= currentYear &amp;&amp; currentYear &lt;= maxDateInYears){
					indicesToHighlight.push(i);
				}
			}
		});
		Vis.selectItems( indicesToHighlight );

	}
	
	TIMEVIS.Evt.brushended = function(){
	
		// update zoom after brushing
		var currentExtent = Math.abs(new Date(x.invert(width)) - new Date(x.invert(0)));	
		var scale = fullExtent / currentExtent;
		var tx = -1 * (x2(brush.extent()[0]) * scale);
		var ty = zoom.translate()[1];
		
		zoom.scale(scale);
		zoom.translate([tx, ty]);	
		
		TIMEVIS.Evt.filterListPerTime(x.invert(0).getFullYear(),x.invert(width).getFullYear());
	};
	
	
	/**
	 * Zoom zoomed
	 * */
	TIMEVIS.Evt.zoomed = function(){
		
		// Define zoom settings
		var trans = zoom.translate();
		var scale = zoom.scale();
		
		tx = Math.min(0, Math.max(width * (1 - scale), trans[0]));
		ty = trans[1];
		
		zoom.translate([tx, ty]);
		
		// update brush extent
		var brushExtent = [x.invert(0), x.invert(width)];
		context.select(&quot;.brush&quot;).call(brush.extent(brushExtent));
		
		// update handles&#x27; position
		leftHandle.attr(&quot;x&quot;, x2(brushExtent[0]) - 12);
		rightHandle.attr(&quot;x&quot;, x2(brushExtent[1]) - 8);
	
		TIMEVIS.Render.redraw();
		
		TIMEVIS.Evt.filterListPerTime(brushExtent[0].getFullYear(),brushExtent[1].getFullYear());
		
	};
	
	
	
	
	
	/**
	 * Node click handler
	 **/
	TIMEVIS.Evt.nodeClicked = function( d, index, sender ) {
	
		kwNodes = [];
		var links = [];
	
		// Remove existing lines, , kwNodes and text, and restore nodes
		TIMEVIS.Render.remove();
		
		// if the same node is selected twice and the lines were drawn in the previous run, then no lines are drawn in this run
		if(d.id == selectedId){
			selectedId = &quot;undefined&quot;;
			flagLines = false;
			
			if( sender != Vis )
				Vis.ListItemSelected(d, index);	// if the method is invoked by Vis template
			
			return;
		}
		selectedId = d.id;

		// Set opacity and stroke to highlight selected node
		TIMEVIS.Render.highlightNodes( [index] );

		// highlight current datum on content list
		if( sender != Vis )
			Vis.ListItemSelected(d, index);
		
		/**
		 *  Draw lines linking nodes in focus area
		 */
		if(d.keywords.length == 0)
			return;
	
		flagLines = true;				// when set to true, it allows redrawing lines when brushing or zooming
	 	
		d.keywords.forEach(function(k, i){
		
			var source = { &#x27;xValue&#x27;: d[xAxisChannel], &#x27;yValue&#x27;: d[yAxisChannel], &#x27;xOffset&#x27;: 0, &#x27;yOffset&#x27;: 0 };
			var points = TIMEVIS.Internal.getKeywordNode(d, k, i);		
		
			kwNodes.push(points.target);
			links.push([source, points.midpoint, points.target]);
		});
		
		TIMEVIS.Render.DrawKeywordNodeAndLinks( links );
		
	};		// end nodeclick


	/** 
	 * Node mouseover handler
	 * */	
	TIMEVIS.Evt.nodeMouseOvered = function(d){
	
		//if(d.isHighlighted){
			currentExtent = Math.abs(new Date(x.invert(width)) - new Date(x.invert(0)));
		
			// node colored in red
			d3.select(this)
				.attr(&quot;r&quot;, function(d){ 
					var radius = Geometry.calculateRadius(fullExtent, currentExtent);
					if(d.isHighlighted)
						return parseFloat(radius) + 2;
					return parseFloat(radius) + 1;
				})
				.style(&quot;fill&quot;, &quot;red&quot;)
				.style(&quot;stroke-width&quot;, &quot;2.5px&quot;);					

			// Get current x/y values, then augment for the tooltip
			var xPosition = parseFloat(d3.select(this).attr(&quot;cx&quot;)) + 250;//45;
			var yPosition = parseFloat(d3.select(this).attr(&quot;cy&quot;)) + 120;//35;
	
			d3.select(&quot;#tooltip&quot;).remove();
		
			tooltip = d3.select( root ).append( &quot;div&quot; )
						.attr(&quot;id&quot;, &quot;tooltip&quot;);
	
			tooltip.append(&quot;p&quot;)
			.attr(&quot;id&quot;, &quot;value&quot;);
	
			// Show the toolxtip
			tooltip
				.style(&quot;left&quot;, xPosition + &quot;px&quot;)
				.style(&quot;top&quot;, yPosition + &quot;px&quot;)
				.style(&quot;opacity&quot;, 0.4)
				.transition()	// With this line the circles have black borders
				.style(&quot;opacity&quot;, 0.9)
				.duration(1000);				
	
			// Add text and link to the tooltip
			tooltip
				.select(&quot;#value&quot;)
				.html(&#x27;&lt;a target=\&quot;_blank\&quot; href=\&quot;&#x27; + d.uri + &#x27;\&quot;&gt;&#x27; + d.title + &#x27;&lt;/a&gt;&lt;br/&gt; &lt;p&gt;Year: &#x27; + toYear(d.year) + &quot;&lt;/p&gt;&quot;);
		//}
	};


	/**
	 * 	Node mouseout handler
	 * */	
	TIMEVIS.Evt.nodeMouseOuted = function(d){
	
		//if(d.isHighlighted){
			currentExtent = Math.abs(new Date(x.invert(width)) - new Date(x.invert(0)));
		
			// Restore node&#x27;s fill to original color and radius
			d3.select(this)
				.attr(&quot;r&quot;, function(d){ 
					var radius = Geometry.calculateRadius(fullExtent, currentExtent);
					if(d.isHighlighted)
						return parseFloat(radius) + 1;
					return parseFloat(radius);
				})
				.style(&quot;fill&quot;, function(d){ return color(d[colorChannel]); })
				.style(&quot;stroke-width&quot;, &quot;2px&quot;);
			
			//Hide tooltip
			tooltip.transition().duration(1500).style(&quot;opacity&quot;, 0);
	
			tooltip
				.transition()
				.remove()
				.duration(0).delay(1500);
		//}
	};
	
	
	/**
	 *	Keyword nodes&#x27; handlers
	 * */	
	TIMEVIS.Evt.kwnodeClicked = function(d){
		Vis.keywordSelected(d.title);
	};
	
	
	TIMEVIS.Evt.kwnodeMouseOvered = function(){
		//d3.select(this).select(&quot;.keywordDot&quot;).style(&quot;stroke&quot;, &quot;red&quot;);
		d3.select(this).select(&quot;.keywordDot&quot;).style(&quot;fill&quot;, &quot;red&quot;);
		d3.select(this).select(&quot;.shadow&quot;).style(&quot;stroke&quot;, &quot;yellow&quot;);
		d3.select(this).select(&quot;.shadow&quot;).style(&quot;opacity&quot;, &quot;0.3&quot;);
	};
	
	
	TIMEVIS.Evt.kwnodeMouseOuted = function(){
		//d3.select(this).select(&quot;.keywordDot&quot;).style(&quot;stroke&quot;, &quot;none&quot;);
		d3.select(this).select(&quot;.keywordDot&quot;).style(&quot;fill&quot;, &quot;blue&quot;);
		d3.select(this).select(&quot;.shadow&quot;).style(&quot;stroke&quot;, &quot;#ddd&quot;);
		d3.select(this).select(&quot;.shadow&quot;).style(&quot;opacity&quot;, &quot;0.7&quot;);
	};
	
	
	/**
	 *	Legend events&#x27; handlers
	 * */
	TIMEVIS.Evt.legendClicked = function( legendDatum, legendIndex ){
		
		var indicesToHighlight = [];
		
		if( legendDatum.selected === false ){				
			data.forEach(function(d, i){
				if(d[colorChannel] === legendDatum.item)
					indicesToHighlight.push(i);
			});
			
			legendDomain.forEach(function(l, i){
				l.selected = (i == legendIndex);
			});
		}
		else{
			legendDatum.selected = false;
		}
		
		TIMEVIS.Render.highlightNodes( indicesToHighlight, $(this).attr(&#x27;class&#x27;) );
		Vis.selectItems( indicesToHighlight );
		
		if(legendDatum.selected === true){
			$(this).find(&#x27;text&#x27;).css(&#x27;font-weight&#x27;, &#x27;bold&#x27;);
		}else{
			Vis.selectItems(Vis.getAllSelectListItems());
		}
		
		d3.selectAll(&#x27;.legend&#x27;).select(&quot;div&quot;)
			.style(&quot;border&quot;, function(l, i){ if(i == legendIndex &amp;&amp; legendDatum.selected) return &quot;0.1em lime solid&quot;; return &quot;none&quot;; });
		
	};
	
	
	TIMEVIS.Evt.legendMouseOvered = function(d){

		d3.select(this).select(&quot;div&quot;)
			.style(&quot;border&quot;, &quot;0.1em yellow solid&quot;)
			.style(&quot;width&quot;, &quot;1.4em&quot;)
			.style(&quot;height&quot;, &quot;1.4em&quot;);
		
		d3.select(this).select(&quot;text&quot;)
			.style(&quot;font-size&quot;, &quot;0.9em&quot;);
	};
	
	
	TIMEVIS.Evt.legendMouseOuted = function(d){
		
		d3.select(this).select(&quot;div&quot;)
			.style(&quot;border&quot;, function(){ if(d.selected) return &quot;0.1em lime solid&quot;; return &quot;none&quot;; })
			.style(&quot;width&quot;,  function(){ if(d.selected) return &quot;1.4em&quot;; return &quot;1.5em&quot;; })
			.style(&quot;height&quot;, function(){ if(d.selected) return &quot;1.4em&quot;; return &quot;1.5em&quot;; });
		
		d3.select(this).select(&quot;text&quot;)
			.style(&quot;font-size&quot;, &quot;0.85em&quot;);
		
	};
	

	
	
	
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	TIMEVIS.Internal = {};	
	
	
	
	TIMEVIS.Internal.getKeywordNode = function(d, k, i){
		
		var tGmtry = Geometry.getXandYOffset(x(d[xAxisChannel]), width, d, i);
	
		var t = { 
					&#x27;xValue&#x27;  : d[xAxisChannel], 
					&#x27;yValue&#x27;  : d[yAxisChannel],
					&#x27;xOffset&#x27; : tGmtry.xOffset, 
					&#x27;yOffset&#x27; : tGmtry.yOffset, 
					&#x27;factor&#x27;  : tGmtry.factor, 
					&#x27;title&#x27;   : k.term 
				};
		
		var mGmtry = Geometry.getMidPoint(tGmtry);
		
		var m = {
					&#x27;xValue&#x27;  : d[xAxisChannel], 
					&#x27;yValue&#x27;  : d[yAxisChannel],
					&#x27;xOffset&#x27; : mGmtry.xOffset, 
					&#x27;yOffset&#x27; : mGmtry.yOffset, 
					&#x27;factor&#x27;  : mGmtry.factor
				};
		
		return {&#x27;target&#x27;: t, &#x27;midpoint&#x27;: m};
	};
	
	
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	TIMEVIS.Render = {};
	
	
	
	/******************************************************************************************************************************
	* 
	* 	Draw function called from Vis-Template every time the visual channels or the data change
	*  
	*****************************************************************************************************************************/	
	
	TIMEVIS.Render.draw = function(initData, mapping, iWidth, iHeight){

		/******************************************************
		 * Define canvas dimensions
		 ******************************************************/
		
		TIMEVIS.Dimensions = TIMEVIS.Settings.getDimensions(root, iWidth, iHeight);
		width          = TIMEVIS.Dimensions.width;
		focusHeight    = TIMEVIS.Dimensions.focusHeight;
		focusMargin    = TIMEVIS.Dimensions.focusMargin;
		contextHeight  = TIMEVIS.Dimensions.contextHeight;
		contextMargin  = TIMEVIS.Dimensions.contextMargin;
		centerOffset   = TIMEVIS.Dimensions.centerOffset;
		verticalOffset = TIMEVIS.Dimensions.verticalOffset;
		
		
		/******************************************************
		 * Assign visual channels and processed data
		 ******************************************************/

        TIMEVIS.Input = TIMEVIS.Settings.getInitData(initData, mapping);
		xAxisChannel = TIMEVIS.Input.xAxisChannel;
		yAxisChannel = TIMEVIS.Input.yAxisChannel;
		colorChannel = TIMEVIS.Input.colorChannel;
		data 		 = TIMEVIS.Input.data;
		keywords	 = TIMEVIS.Input.keywords;
		
		selectedId = &quot;undefined&quot;; 
		flagLines = false;

		/******************************************************
		 *	Define scales
		 *****************************************************/ 
	
		// main X Axis
		x  = d3.time.scale()									
					.range([0, width])
					.domain(d3.extent(data, function(d){ return d[xAxisChannel]; })).nice(d3.time.year);
	
	
		// brush X Axis
		x2 = d3.time.scale()
					.range([0, width])
					.domain(x.domain());
	
		// main Y Axis
		y  = d3.scale.ordinal()
					.rangePoints([0, focusHeight], 1.8)
					.domain(data.map(function(d){ return d[yAxisChannel]; })); // maps to nominal values contained in d.topic
	
		
		// brush Y Axis
		y2 = d3.scale.ordinal()
					.rangePoints([0, contextHeight], 0.5)
					.domain(y.domain()); 			
		
		color = d3.scale.category10();		// selects a set of colors for the dots and legends
		
		TIMEVIS.Ext.colorScale = color;
		
		// Calculate full extent
		fullExtent = Math.abs(new Date(x2.invert(width)) - new Date(x2.invert(0)));


		/******************************************************
		 *	Define axis
		 *****************************************************/
		
		// main X Axis
		xAxis = d3.svg.axis().scale(x)
						.orient(&quot;bottom&quot;)
						.ticks(6)
						.tickFormat(d3.time.format(&quot;%Y&quot;));
	
		// main Y Axis
		yAxis = d3.svg.axis().scale(y).orient(&quot;left&quot;);//.tickSize(-width, 0, 0);
	
		// brush X Axis
		xAxis2 = d3.svg.axis().scale(x2)
						.orient(&quot;bottom&quot;)
						.tickFormat(d3.time.format(&quot;%Y&quot;));
	
		// brush Y Axis
		yAxis2 = d3.svg.axis().scale(y2).orient(&quot;left&quot;);
	
	
		/******************************************************
		 *	Define behaviors
		 *****************************************************/ 
	
		////	Brush
		 		
		brush = d3.svg.brush()
				.x(x2)
				.on(&quot;brush&quot;, TIMEVIS.Evt.brushed)
				.on(&quot;brushend&quot;, TIMEVIS.Evt.brushended);	
	
		////	Zoom
		zoom = d3.behavior.zoom()
				.x(x)
				.scaleExtent([1, 10])
				.on(&quot;zoom&quot;, TIMEVIS.Evt.zoomed);
		
		// Call zoom
		zoom.x(x);
		
		/******************************************************
		*	Draw chart main components
		******************************************************/
	
		// Add svg main component
		var divchart = d3.select( root ).append( &quot;div&quot; )
			.attr(&quot;id&quot;, &quot;div-chart&quot;);
	
		var svg = divchart.append(&quot;svg&quot;)
			.attr(&quot;class&quot;, &quot;svg&quot;)
			.attr(&quot;width&quot;, width + focusMargin.left + focusMargin.right)
			.attr(&quot;height&quot;, focusHeight + focusMargin.top + focusMargin.bottom);
	
	
		// Add focus and context g components
		focus = svg.append(&quot;g&quot;)
			.attr(&quot;class&quot;, &quot;focus&quot;)
			.attr(&quot;transform&quot;, &quot;translate(&quot; + focusMargin.left + &quot;,&quot; + focusMargin.top + &quot;)&quot;)
			.call(zoom);
	
		context = svg.append(&quot;g&quot;)
			.attr(&quot;class&quot;, &quot;context&quot;)
			.attr(&quot;transform&quot;, &quot;translate(&quot; + contextMargin.left + &quot;,&quot; + contextMargin.top + &quot;)&quot;);
	
	
		// Add clip-path (area where the chart is drawn)
		var clip = focus.append(&quot;defs&quot;).append(&quot;svg:clipPath&quot;)
			.attr(&quot;id&quot;, &quot;clip&quot;)
			.attr(&quot;pointer-events&quot;, &quot;all&quot;)
			.append(&quot;rect&quot;)
				.attr(&quot;x&quot;, -22)
				.attr(&quot;width&quot;, width + 44)
				.attr(&quot;y&quot;, -10)
				.attr(&quot;height&quot;, focusHeight + 10)
				.attr(&quot;pointer-events&quot;, &quot;all&quot;);
	
		// &quot;g&quot; that contains zoomable/brushable elements
		chart = focus.append(&quot;g&quot;)
			.attr(&quot;id&quot;, &quot;chart&quot;)
			.attr(&quot;clip-path&quot;, &quot;url(#clip)&quot;)
			.attr(&quot;pointer-events&quot;, &quot;all&quot;);
	
		// Add rectangle delimiting zooming area		
		chart.append(&quot;rect&quot;)
			.attr(&quot;class&quot;, &quot;pane&quot;)
			.attr(&quot;x&quot;, -22)
			.attr(&quot;width&quot;, width + 44)
			.attr(&quot;height&quot;, focusHeight);
	
		/**
		 *	Draw axis in focus area
		 */

		// Add X Axis
		focus.append(&quot;g&quot;)
		.attr(&quot;class&quot;, &quot;x axis&quot;)
		.attr(&quot;transform&quot;, &quot;translate(0,&quot; + focusHeight + &quot;)&quot;)
		.call(xAxis)
		.append(&quot;text&quot;)
			.attr(&quot;class&quot;, &quot;label&quot;)
			.attr(&quot;x&quot;, width)
			.attr(&quot;y&quot;, -6)
			.style(&quot;text-anchor&quot;, &quot;end&quot;)
			.text(&quot;Time&quot;);

		// Add Y Axis
		var y_axis = focus.append(&quot;g&quot;)					
						.attr(&quot;class&quot;, &quot;y axis&quot;)
						.call(yAxis);
		
		//y_axis.selectAll(&quot;.tick&quot;).style(&quot;stroke-dasharray&quot;, (&quot;3, 3&quot;));
		
		y_axis
			.selectAll(&quot;.tick &gt; text&quot;)
				.attr(&quot;transform&quot;, &quot;rotate(-45)&quot;)
				//.attr(&quot;y&quot;, &quot;4&quot;)
				.attr(&quot;dx&quot;, &quot;-1.0em&quot;)
				.attr(&quot;dy&quot;, &quot;-2.4em&quot;)
				.style(&quot;text-anchor&quot;, &quot;middle&quot;);
		 
	
		/******************************************************
		 *	Draw in focus area
		 *****************************************************/	
		
		/**
		 *	Main nodes 
		 * */
		//steff experimental code begin
		//console.log(data);
		//console.log(mapping[1].facet);
		 
		//get information(number) about nodes with same x- and y-axis;
		var keyForData = mapping[1].facet;
		 
		var dataDictWithTime ={}; //double dict
		 
		var workInXAxis = function(dataVal,dateString,key){
			if(dataVal[key].hasOwnProperty(dateString)){ //work in x axis
				dataVal[key][dateString] += 1;
			}
			else{
				dataVal[key][dateString] = 1;
			}
		}
		
		var yearInString;
		var currentKeyValue;
		data.forEach(function(currentData){
			yearInString = currentData.year.getFullYear().toString();
			currentKeyValue = currentData[keyForData];
			
			if(dataDictWithTime.hasOwnProperty(currentKeyValue)){//work in y axis
				workInXAxis(dataDictWithTime,yearInString,currentKeyValue);
			}
			else{
				dataDictWithTime[currentKeyValue] ={};
				workInXAxis(dataDictWithTime,yearInString,currentKeyValue);
			}
		});
		//steff experimental code end
		 
		currentExtent = Math.abs(new Date(x.invert(width)) - new Date(x.invert(0)));
		
		var nodesData = chart.selectAll(&quot;.node&quot;).data(data);
		
		var nodes = nodesData.enter()
					.append(&quot;g&quot;)
						.attr(&quot;class&quot;, &quot;node&quot;);
		
		nodes.append(&quot;circle&quot;)
			.attr(&quot;class&quot;, &quot;dot&quot;)	// With this line the circles have black borders
			.attr(&quot;r&quot;, Geometry.calculateRadius(fullExtent, currentExtent))//x.invert(0), x.invert(width)))		
			.attr(&quot;cx&quot;, function(d) { return x(d[xAxisChannel]); })
			.attr(&quot;cy&quot;, function(d) { return y(d[yAxisChannel]); })
			.attr(&quot;fill&quot;, function(d) { return color(d[colorChannel]); })
			.style(&quot;opacity&quot;, 0.3)
			.transition()	
				.style(&quot;opacity&quot;, 1)
				.duration(1500);

		//steff experimental code begin
		nodes.append(&quot;text&quot;)
			.attr(&quot;class&quot;, &quot;number&quot;)
			.attr(&quot;x&quot;, function(d) { return x(d[xAxisChannel])-5; })
			.attr(&quot;y&quot;, function(d) { return y(d[yAxisChannel])+3; })
			//.style(&quot;opacity&quot;, 0.3)
			.text(function(d){
				var numberWithSameTime = dataDictWithTime[d[keyForData]][d.year.getFullYear().toString()];
				if(numberWithSameTime&gt;1){
					return numberWithSameTime;
				} 
				//count same node with same y-axis and time
			});
		textInCircles = chart.selectAll(&quot;.number&quot;);
		
		textInCircles
			.on( &quot;click&quot;, TIMEVIS.Evt.nodeClicked );
		//steff experimental code end
		
		circles = chart.selectAll(&quot;.dot&quot;);
		
		circles
			.on( &quot;click&quot;, TIMEVIS.Evt.nodeClicked )
			.on( &quot;mouseover&quot;, TIMEVIS.Evt.nodeMouseOvered )
			.on( &quot;mouseout&quot;, TIMEVIS.Evt.nodeMouseOuted );
		 
	
		// Add keyword nodes
	
		keywordNodes = chart.selectAll(&quot;.keywordNode&quot;);
		keywordNodeData = keywordNodes.data(kwNodes);
	
		
		/******************************************************
		 *	Legends
		 *****************************************************/	
		
		legendDomain = getLegendDomain(color.domain());
		
		
		var legendWrapper = d3.select(&quot;#div-chart&quot;)
						.append(&quot;div&quot;)
						.attr(&quot;id&quot;, &quot;div-wrap-legends&quot;);
		
		legend = legendWrapper.selectAll(&quot;.legend&quot;)
			.data(legendDomain)
			.enter()
			.append(&quot;div&quot;)
				.attr(&quot;class&quot;, &quot;legend&quot;)
				.attr(&quot;transform&quot;, function(d, i) { return &quot;translate(40,&quot; + (i+1)*20 + &quot;)&quot;; })
				.on( &quot;click&quot;, TIMEVIS.Evt.legendClicked )
				.on( &quot;mouseover&quot;, TIMEVIS.Evt.legendMouseOvered )
				.on( &quot;mouseout&quot;, TIMEVIS.Evt.legendMouseOuted );
		
		legend.append(&quot;div&quot;)
			.attr(&quot;x&quot;, width + 126)
			.style(&quot;background&quot;, function(d){ return color(d.item); });
		
		legend.append(&quot;text&quot;)
			.attr(&quot;x&quot;, width +120)
			.attr(&quot;y&quot;, 9)
			.attr(&quot;dy&quot;, &quot;.35em&quot;)
			.style(&quot;text-anchor&quot;, &quot;end&quot;)
			.text(function(d) { return d.item; });

	
		/******************************************************
		 *	Draw in context area (brush)
		 *****************************************************/		

		// Draw X Axis in context area
		context.append(&quot;g&quot;)
			.attr(&quot;class&quot;, &quot;x axis&quot;)
			.attr(&quot;transform&quot;, &quot;translate(0,&quot; + contextHeight + &quot;)&quot;)
			.call(xAxis2);

		
		// Draw small nodes
		var smallNodes = context.append(&quot;g&quot;);

		smallNodes.selectAll(&quot;.mindot&quot;)
			.data(data)
			.enter()
			.append(&quot;circle&quot;)
				.attr(&quot;class&quot;, &quot;mindot&quot;)	// With this line the circles have black borders
				.attr(&quot;r&quot;, 3)
				.attr(&quot;cx&quot;, function(d) { return x2(d[xAxisChannel]); })
				.attr(&quot;cy&quot;, function(d) { return y2(d[yAxisChannel]); })
				.attr(&quot;fill&quot;, function(d) { return color(d[colorChannel]); })
				.style(&quot;stroke-width&quot;, &quot;1px&quot;);
		
		
		// Draw left and right handles for brush
		leftHandle = context.append(&quot;image&quot;)
			.attr(&quot;width&quot;, 20)
			.attr(&quot;height&quot;,contextHeight + 10)
			.attr(&quot;x&quot;, x2(x2.domain()[0]) - 12)
			.attr(&quot;y&quot;, -7)
			.attr(&quot;xlink:href&quot;, leftHandleImg);

		rightHandle = context.append(&quot;image&quot;)
			.attr(&quot;width&quot;, 20)
			.attr(&quot;height&quot;, contextHeight + 10)
			.attr(&quot;x&quot;, x2(x2.domain()[1]) - 8)
			.attr(&quot;y&quot;, -7)
			.attr(&quot;xlink:href&quot;, rightHandleImg);
		
		// Draw brush	
		context.append(&quot;g&quot;)
			.attr(&quot;class&quot;, &quot;x brush&quot;)
			.call(brush)
				.selectAll(&quot;rect&quot;)
				.attr(&quot;y&quot;, -2)
				.attr(&quot;height&quot;, contextHeight + 0);

		// Set brush&#x27;s initial extension	
		var brushExtent = [x.invert(0), x.invert(width)];
		context.select(&quot;.brush&quot;).call(brush.extent(brushExtent));
		
	};	// end Render.draw
	
	
	
	
	
	
	/*****************************************************************************************************************
	* 
	*	Method called when a node is clicked. Displays a small green node for each keyword related to the node item,
	*	the links connecting them and te corresponding text
	*
	* ****************************************************************************************************************/
	TIMEVIS.Render.DrawKeywordNodeAndLinks = function( links ){
	
		links.forEach(function(points) { 
	
			chart.append(&quot;g&quot;)
				.attr(&quot;class&quot;, &quot;keywordLink&quot;)
				.append(&quot;path&quot;)
					.datum(points)
					.attr(&quot;class&quot;, &quot;link&quot;)					
					.attr(&quot;d&quot;, lineFunction(points))
					.attr(&quot;transform&quot;, &quot;translate(&quot;+(kwNodes[0].factor * -10)+&quot;)&quot;)	// animation for keyword lines
					.transition()
					.ease(&quot;linear&quot;)
					.duration(delay)
					.attr(&quot;transform&quot;, &quot;translate(0)&quot;);
		});

		// 	Add keyword nodes	
		keywordNodeData = keywordNodes.data(kwNodes);

		var gKeyword = keywordNodeData
			.enter()
			.append(&quot;g&quot;)
				.attr(&quot;class&quot;, &quot;keywordNode&quot;)
				.attr(&quot;id&quot;, function(d,i){ return &quot;keywordNode_&quot;+i; })
				.attr(&quot;dx&quot;, function(d) { return x(d.xValue) + d.xOffset; })
				.attr(&quot;dy&quot;, function(d) { return y(d.yValue) + d.yOffset; })
				.on(&quot;click&quot;, TIMEVIS.Evt.kwnodeClicked)
				.on(&quot;mouseover&quot;, TIMEVIS.Evt.kwnodeMouseOvered)
				.on(&quot;mouseout&quot;, TIMEVIS.Evt.kwnodeMouseOuted);

		// Append circles to keywordNodes
		gKeyword
			.append(&quot;circle&quot;)
				.attr(&quot;class&quot;, &quot;keywordDot&quot;)
				.transition()
				.attr(&quot;r&quot;, &quot;4&quot;)		
				.attr(&quot;cx&quot;, function(d) { return x(d.xValue) + d.xOffset; })
				.attr(&quot;cy&quot;, function(d) { return y(d.yValue) + d.yOffset; })
				.duration(0).delay(delay + 50);

	
		setTimeout(function(){
			// Append text to keywordNodes
			gKeyword
			.append(&quot;text&quot;)
				.text(function(d) { return d.title; })
				.attr(&quot;class&quot;, &quot;shadow&quot;)
				.attr(&quot;x&quot;, function(d, i) { return x(d.xValue) + d.xOffset + Geometry.getTextXoffset(d, i); })	// function getTextXoffset() in geometry.js 
				.attr(&quot;y&quot;, function(d, i) { return y(d.yValue) + d.yOffset + Geometry.getTextYoffset(d, i, kwNodes.length); });	// function getTextYoffset() in geometry.js
		
			gKeyword
				.append(&quot;text&quot;)
					.text(function(d) { return d.title; })
					.attr(&quot;class&quot;, &quot;node_text&quot;)
					.attr(&quot;x&quot;, function(d, i) { return x(d.xValue) + d.xOffset + Geometry.getTextXoffset(d, i); })	// function getTextXoffset() in geometry.js 
					.attr(&quot;y&quot;, function(d, i) { return y(d.yValue) + d.yOffset + Geometry.getTextYoffset(d, i, kwNodes.length); });	// function getTextYoffset() in geometry.js
		
		}, delay + 100);
	};
	
	
	
	
	/******************************************************************************************************************
	* 
	*	Redraw nodes, lines and main x axis
	* 
	* ***************************************************************************************************************/
	TIMEVIS.Render.redraw = function(){
		
		currentExtent = Math.abs(new Date(x.invert(width)) - new Date(x.invert(0)));
		
		// update x axis
		focus.select(&quot;.x.axis&quot;).call(xAxis);
	
		// redraw nodes
		circles
			.attr(&quot;cx&quot;, function(d) { return x(d[xAxisChannel]); })
			.attr(&quot;cy&quot;, function(d) { return y(d[yAxisChannel]); })
			.attr(&quot;r&quot;, function(d){ 
				var radius = Geometry.calculateRadius(fullExtent, currentExtent);
				if(d.isHighlighted) 
					return radius + 1;
				return radius;
			})
			.attr(&quot;fill&quot;, function(d) { return color(d[colorChannel]); });
		
		// redraw text
		textInCircles
			.attr(&quot;x&quot;, function(d) { return x(d[xAxisChannel])-5; })
			.attr(&quot;y&quot;, function(d) { return y(d[yAxisChannel])+3; });
		
		// if lines are already drawn, redraw them
		if(flagLines){
  		
			chart.selectAll(&quot;.link&quot;).attr(&quot;d&quot;, lineFunction);
  				
			// redraw keyword nodes
			chart.selectAll(&quot;.keywordDot&quot;)
				.attr(&quot;r&quot;, &quot;4&quot;)		
				.attr(&quot;cx&quot;, function(d) { return x(d.xValue) + d.xOffset; })
				.attr(&quot;cy&quot;, function(d) { return y(d.yValue) + d.yOffset; })
				.attr(&quot;fill&quot;, &quot;blue&quot;);
		
			// redraw text and shadow for keyword nodes
			chart.selectAll(&quot;.shadow&quot;)	
				.attr(&quot;x&quot;, function(d, i) { return x(d.xValue) + d.xOffset + Geometry.getTextXoffset(d, i); })
				.attr(&quot;y&quot;, function(d, i) { return y(d.yValue) + d.yOffset + Geometry.getTextYoffset(d, i, kwNodes.length); });			
			
			chart.selectAll(&quot;.node_text&quot;)	
			.attr(&quot;x&quot;, function(d, i) { return x(d.xValue) + d.xOffset + Geometry.getTextXoffset(d, i); })
			.attr(&quot;y&quot;, function(d, i) { return y(d.yValue) + d.yOffset + Geometry.getTextYoffset(d, i, kwNodes.length); });
		}  
	};

	
	
	/******************************************************************************************************************
	* 
	*	Reset chart&#x27;s elements
	* 
	* ***************************************************************************************************************/  
	TIMEVIS.Render.reset = function(){
	
		// reset zoom
		zoom.scale(1);
		zoom.translate([0, 0]);
	
		// remove lines, refdots and text, and restore dots appearance
		TIMEVIS.Render.remove();
	
		// restore x scale domain
		x.domain(x2.domain());
	
		//reset brush
		var brushExtent = [x.invert(0), x.invert(width)];
		context.select(&quot;.brush&quot;).call(brush.extent(brushExtent));
		
		// reset brush handles&#x27; position
		leftHandle.attr(&quot;x&quot;, x2(x2.domain()[0]) - 12);
		rightHandle.attr(&quot;x&quot;, x2(x2.domain()[1]) - 8);

		flagLines = false;

	};
	

	
	
	/*****************************************************************************************************************
	* 
	*	Remove links, keyword nodes and restore main nodes&#x27; style
	*
	* **************************************************************************************************************/
		
	TIMEVIS.Render.remove = function(){
			
		chart.selectAll(&quot;.keywordLink&quot;).remove();
		chart.selectAll(&quot;.link&quot;).remove();
		chart.selectAll(&quot;.keywordNode&quot;).empty();
		chart.selectAll(&quot;.keywordNode&quot;).remove();
		//chart.selectAll(&quot;.keywordDot&quot;).remove();
		chart.selectAll(&quot;.text&quot;).remove();
		
		keywordNodeData.exit().remove();
		
		currentExtent = Math.abs(new Date(x.invert(width)) - new Date(x.invert(0)));
			
		circles
			.attr(&quot;r&quot;, Geometry.calculateRadius(fullExtent, currentExtent))
			.style(&quot;stroke&quot;, &quot;darkgrey&quot;)
			.style(&quot;opacity&quot;, &quot;1&quot;);
	
		textInCircles
			.style(&quot;opacity&quot;, &quot;1&quot;);
			
		data.forEach(function(d){ d.isHighlighted = false; });
			
		$(&#x27;.legend&#x27;).find(&#x27;text&#x27;).css(&#x27;font-weight&#x27;, &#x27;normal&#x27;);
		d3.select(&#x27;.legend&#x27;).select(&quot;div&quot;).style(&quot;border&quot;, &quot;none&quot;)
	};
		
		
		
	/******************************************************************************************************************
	* 
	*	Nodes can be highlighted from the Vis-Template though the following function
	* 
	* ***************************************************************************************************************/
		
	TIMEVIS.Render.highlightNodes = function( nodesToHighlight, sender ){

        TIMEVIS.Render.remove();

        var radius = Geometry.calculateRadius(fullExtent, currentExtent);

		// if length &gt; 0 there are nodes to highlight, otherwise tag box is empty and no node should be highlighted
		if(nodesToHighlight.length &gt; 0) {

	
			circles
				.attr(&quot;r&quot;, function(d, i){
					if(nodesToHighlight.indexOf(i) != -1){
						d.isHighlighted = true;
						return parseFloat(radius) + 1;
					}
					d.isHighlighted = false;
					return radius;
				})
				.style(&quot;stroke&quot;, function(d, i){
					if(nodesToHighlight.indexOf(i) != -1)
						return &quot;black&quot;;
					return &quot;darkgrey&quot;;
				})
				.style(&quot;opacity&quot;, function(d, i){
					if(nodesToHighlight.indexOf(i) != -1)
						return 1;
					return 0.1;
				});
				
			textInCircles
				.style(&quot;opacity&quot;, function(d, i){
					if(nodesToHighlight.indexOf(i) != -1)
						return 1;
					return 0.1;
				});
				
		}
        else{

            circles
                .attr(&quot;r&quot;, radius)
                .style(&quot;stroke&quot;, &quot;darkgrey&quot;)
                .style(&quot;opacity&quot;, 1);
				
			textInCircles	
				.style(&quot;opacity&quot;, 1);
        }

		if(sender !== &#x27;legend&#x27;)
			this.clearLegends();
	};
		
		
		
	TIMEVIS.Render.clearLegends = function(){
			
		legendDomain.forEach(function(l){
			l.selected = false;
		});
		
		$(&#x27;.legend&#x27;).find(&#x27;text&#x27;).css(&#x27;font-weight&#x27;, &#x27;normal&#x27;);
		d3.selectAll(&#x27;.legend&#x27;).select(&quot;div&quot;).style(&quot;border&quot;, &quot;none&quot;);
	};
	
	
	
	
	/******************************************************************************************************************
	* 
	*	Nodes can be selected from the Vis-Template by indicating a single index or an array of indices
	* 
	* *****************************************************************************************************************/

	TIMEVIS.Render.selectNodes = function( nodesIndices, sender ){
		
		if( Array.isArray(nodesIndices) ){
			TIMEVIS.Render.highlightNodes( nodesIndices );
		}
		else if( typeof nodesIndices != &#x27;undefined&#x27; &amp;&amp; nodesIndices != &#x27;undefined&#x27; ){
			var index = nodesIndices;
			var datum = TIMEVIS.Input.data[index];
		
			TIMEVIS.Evt.nodeClicked(datum, index, sender);
		}	
	};
		
		

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	TIMEVIS.Ext = {
		
		draw : function(initData, mapping, iWidth, iHeight){
			TIMEVIS.Render.draw(initData, mapping, iWidth, iHeight);
		},
		
		reset : function(){
			TIMEVIS.Render.reset();
			TIMEVIS.Render.redraw();
		},
		
		selectNodes : function( indicesToHighlight, sender ){
			TIMEVIS.Render.selectNodes( indicesToHighlight, sender );
		}
			
	};

	
	return TIMEVIS.Ext;
	
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
