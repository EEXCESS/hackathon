<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>common_js/storage.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/EEXCESS.model.common.html">EEXCESS.model.common</a></li>
                                <li><a href="../classes/EEXCESS.model.constants.html">EEXCESS.model.constants</a></li>
                                <li><a href="../classes/EEXCESS.model.interests.html">EEXCESS.model.interests</a></li>
                                <li><a href="../classes/EEXCESS.model.languages.html">EEXCESS.model.languages</a></li>
                                <li><a href="../classes/EEXCESS.model.obfuscation.html">EEXCESS.model.obfuscation</a></li>
                                <li><a href="../classes/EEXCESS.model.policy.html">EEXCESS.model.policy</a></li>
                                <li><a href="../classes/EEXCESS.model.profile.html">EEXCESS.model.profile</a></li>
                                <li><a href="../classes/EEXCESS.model.storage.html">EEXCESS.model.storage</a></li>
                                <li><a href="../classes/EEXCESS.model.util-html.html">EEXCESS.model.util-html</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: common_js/storage.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var EEXCESS = EEXCESS || {};

EEXCESS.storage = (function() {
    var _name = &#x27;eexcess_db&#x27;; // name of the database
    var _version = 43; // version number of the database
    var _db = {}; // the database (needs to be initalized - DO NOT ACCESS DIRECTLY! use _getDB instead)

    // checks, if the provided callback is a function and executes it without parameters
    var _empty_callback = function(callback) {
        if (typeof callback === &#x27;function&#x27;) {
            callback();
        }
    };

    // checks, if the provided callback is a function and executes it with supplied parameter
    var _optional_callback = function(callback, value) {
        if (typeof callback === &#x27;function&#x27;) {
            callback(value);
        }
    };

    /**
     * Wrapper for local storage access. If a value is supplied, it is stored at
     * with the supplied key. Otherwise the function returns the value stored at
     * the supplied key.
     * 
     * @param {String} key The key for which to retrieve/store a value
     * @param {JSON} value (optional) The value to store. If no value is
     * supplied, the value at the supplied key is returned.
     */
    var _local = function(key, value) {
        if (typeof value === &#x27;undefined&#x27;) {
            return localStorage[key];
        } else {
            localStorage[key] = value;
        }
    };

    /**
     * Obtains a connection to the database
     * 
     * @param {function} success success callback, receives the database as parameter
     * @param {function} error (optional) error callback
     */
    var _getDB = function(success, error) {
        if (typeof _db === &#x27;IDBDatabase&#x27;) {
            success(_db);
        } else {
            _init(success, error);
        }
    };

    /**
     * 
     * Puts an object into the desired object store (may overwrite an existing entry)
     * 
     * @param {String} objectStore name of the object store, where the entry should be put in
     * @param {Object} value the value to store
     * @param {Function} error (optional) error callback
     * @param {Function} success (optional) success callback
     */
    var _put = function(objectStore, value, success, error) {
        _getDB(function(db) {
            var tx = db.transaction(objectStore, &#x27;readwrite&#x27;);
            var store = tx.objectStore(objectStore);
            var req = store.put(value);
            req.onsuccess = function() {
                _empty_callback(success);
            };
            req.onerror = function() {
                _empty_callback(error);
            };
        }, _empty_callback(error));
    };

    /**
     * Adds an object to the desired object store
     * @param {String} objectStore name of the object store to which an entry should be added
     * @param {Object} value the object to add
     * @param {Function} success (optional) success callback without parameters
     * @param {Function} error (optional) error callback without parameters
     * @returns {undefined}
     */
    var _add = function(objectStore, value, success, error) {
        _getDB(function(db) {
            var tx = db.transaction(objectStore, &#x27;readwrite&#x27;);
            var store = tx.objectStore(objectStore);
            var req = store.add(value);
            req.onsuccess = function() {
                _empty_callback(success);
            };
            req.onerror = function() {
                _empty_callback(error);
            };
        }, _empty_callback(error));
    };

    /**
     * Stores the closing of a result with to the database. This means updating
     * an existing entry for a started view with the duration of the view.
     * @param {String} resource url of the resource
     * @param {Function} success (optional) success callback, receives the updated entry as parameter
     * @param {Function} error (optional) error callback without parameters
     */
    var _closedRecommendation = function(resource, success, error) {
        _getDB(function(db) {
            var tx = db.transaction(&#x27;resource_relations&#x27;, &#x27;readwrite&#x27;);
            var store = tx.objectStore(&#x27;resource_relations&#x27;);
            var idx = store.index(&#x27;resource&#x27;);
            var curreq = idx.openCursor(resource);

            curreq.onsuccess = function() {
                var cursor = curreq.result;
                if (cursor) {
                    if (cursor.value.type === &#x27;view&#x27; &amp;&amp; typeof cursor.value.duration === &#x27;undefined&#x27;) {
                        cursor.value.duration = new Date().getTime() - cursor.value.timestamp;
                        cursor.update(cursor.value);
                        _optional_callback(success, cursor.value);
                    } else {
                        cursor.continue();
                    }
                } else {
                    _empty_callback(error);
                }
            };
            curreq.onerror = function() {
                _empty_callback(error);
            };
        }, _empty_callback(error));
    };

    /**
     * Stores the rating of a resource. If a rating for this resource is already
     * present within the same context, the rating is updated
     * 
     * @param {Object} rating the rating, including the resource and context
     * @param {Function} success (optional) success callback without parameters
     * @param {Function} error (optional) error callback without parameters
     */
    var _setRating = function(rating, success, error) {
        _getDB(function(db) {
            var entryExists = false;
            var tx = db.transaction(&#x27;resource_relations&#x27;, &#x27;readwrite&#x27;);
            var store = tx.objectStore(&#x27;resource_relations&#x27;);
            var idx = store.index(&#x27;resource&#x27;);
            var curreq = idx.openCursor(rating.resource);

            // if rating with same context is present in database, update it
            curreq.onsuccess = function() {
                var cursor = curreq.result;
                if (cursor) {
                    if (cursor.value.type === &#x27;rating&#x27; &amp;&amp; cursor.value.context.query === rating.context.query) {
                        entryExists = true;
                        rating.id = cursor.primaryKey;
                        cursor.update(rating);
                    } else {
                        cursor.continue();
                    }
                }
            };

            // add new rating to database
            tx.oncomplete = function() {
                if (!entryExists) {
                    var tx2 = db.transaction(&#x27;resource_relations&#x27;, &#x27;readwrite&#x27;);
                    var store2 = tx2.objectStore(&#x27;resource_relations&#x27;);
                    var req = store2.put(rating);
                    req.onsuccess = function() {
                        _empty_callback(success);
                    };
                    req.onerror = function() {
                        _empty_callback(error);
                    };
                }
            };
            tx.onerror = function() {
                _empty_callback(error);
            };
        }, _empty_callback(error));
    };

    /**
     * Obtains the rating for a resource from the database. At the moment, the
     * rating&#x27;s context is not considered (the same result item may be rated 
     * different, when retrieved by different queries), but instead, the first 
     * rating found is returned.
     * 
     * @param {String} uri the uri of the resource for which to retrieve the rating
     * @param {Object} context the context for which to retrieve the rating
     * @param {Function} success success callback, receiving the rating score as parameter
     * @param {Function} error (optional) error callback, receiving the error message as parameter
     */
    var _getRating = function(uri, context, success, error) {
        _getDB(function(db) {
            var tx = db.transaction(&#x27;resource_relations&#x27;);
            var store = tx.objectStore(&#x27;resource_relations&#x27;);
            var idx = store.index(&#x27;resource&#x27;);
            var curreq = idx.openKeyCursor(uri);

            curreq.onsuccess = function() {
                var cursor = curreq.result;
                if (cursor) {
                    var req = store.get(cursor.primaryKey);
                    req.onsuccess = function() {
                        if (typeof req.result !== &#x27;undefined&#x27;) {
                            if (req.result.type === &#x27;rating&#x27;) { // TODO: check context?
                                success(req.result.annotation.hasBody[&#x27;http://purl.org/stuff/rev#rating&#x27;]);
                            } else {
                                cursor.continue();
                            }
                        }
                    };
                } else {
                    _optional_callback(error, &#x27;no entry found&#x27;);
                }
            };
            curreq.onerror = function() {
                _optional_callback(error, &#x27;db error&#x27;);
            };
        }, _optional_callback(error, &#x27;db error&#x27;));
    };

    /**
     * Obtains ratings for a set of results from the database. At the moment, a
     * rating&#x27;s context is not considered (the same result item may be rated
     * different, when retrieved by different queries), but instead, the first
     * rating found is returned.
     *
     * @param {Array} items Array of result objects for which to retrieve ratings
     * @param {Function} success success callback, receiving the updated results as parameter
     * @param {Function} error (optional) error callback
     * @returns {undefined}
     */
    var _getRatings = function(items, success, error) {
        _getDB(function(db) {
            var tx = db.transaction(&#x27;resource_relations&#x27;);
            var store = tx.objectStore(&#x27;resource_relations&#x27;);
            var idx = store.index(&#x27;resource&#x27;);

            var i = 0;
            handleNext(); // initial item (others get handled by callback on success)
            // handle a single item
            function handleNext() {
                if (i &lt; items.length) {
                    var curreq = idx.openCursor(items[i].uri);
                    curreq.onsuccess = function() {
                        var cursor = curreq.result;
                        if (cursor) { // TODO: check context?
                            var req = store.get(cursor.primaryKey);
                            req.onsuccess = function() {
                                if (typeof req.result !== &#x27;undefined&#x27;) {
                                    if (req.result.type === &#x27;rating&#x27;) { // TODO: check context?
                                        items[i].rating = req.result.annotation.hasBody[&#x27;http://purl.org/stuff/rev#rating&#x27;];
                                        i++;
                                        handleNext();
                                    } else {
                                        cursor.continue();
                                    }
                                }
                            };
                        } else {
                            i++;
                            handleNext();
                        }
                    };
                }
            }
            tx.oncomplete = function() {
                success(items);
            };
            tx.onerror = function() {
                _empty_callback(error);
            };
        });
    };

    /**
     * Enriches a visit with its referrer (if any) and stores it in the database
     * 
     * @param {Object} visitItem the visit to store
     * @param {Integere} referringVisitId identifier of the referring visit
     */
    var _storeVisit = function(visitItem, referringVisitId) {
        _getDB(function(db) {
            var tx = db.transaction(&#x27;history&#x27;, &#x27;readwrite&#x27;);
            var store = tx.objectStore(&#x27;history&#x27;);
            var idx = store.index(&#x27;chrome_visitId&#x27;);

            var req = idx.get(referringVisitId);
            req.onsuccess = function() {
                if (typeof req.result !== &#x27;undefined&#x27;) {
                    visitItem.referrer = req.result.url;
                } else {
                    visitItem.referrer = &#x27;&#x27;;
                }
                store.add(visitItem);
            };
        });
    };

    /**
     * Stores recommendations in the database, along with the context in which 
     * they were retrived and a timestamp.
     * 
     * @param {Array} recommendations the recommendations to store
     * @param {Object} context the context in which the recommendations were retrieved
     * @param {long} timestamp the timestamp
     */
    var _storeRecommendations = function(recommendations, context, timestamp) {
        _getDB(function(db) {
            var tx = db.transaction(&#x27;recommendations&#x27;, &#x27;readwrite&#x27;);
            var store = tx.objectStore(&#x27;recommendations&#x27;);
            var idx = store.index(&#x27;uri&#x27;);
            var i = 0;
            handleNext(); // initial item (others get handled by callback on success)
            // handle a single item
            function handleNext() {
                if (i &lt; recommendations.length) {
                    var curreq = idx.openCursor(recommendations[i].uri);
                    curreq.onsuccess = function() {
                        var cursor = curreq.result;
                        if (cursor) {
                            /**
                             * check if recommendation is already present in database for this context
                             * compare context objects by their string representation ATTENTION: attribute order matters!!!
                             */
                            if (JSON.stringify(cursor.value.context) === JSON.stringify(context)) {
                                i++;
                                handleNext();
                            } else {
                                cursor.continue();
                            }
                        } else {
                            store.put({result: recommendations[i], uri: recommendations[i].uri, context: context, timestamp: timestamp}).onsuccess = handleNext;
                            i++;
                        }
                    };
                }
            }
        });
    };

    /**
     * Initializes or updates the database. If the rm_previous parameter is set to true or left empty, the previous entries are removed.
     * 
     * @param {function} success (optional) success callback (receives the database as parameter)
     * @param {function} error (optional) error callback (receives the error object as parameter)
     * @param {type} rm_previous (optional) flag, indicating if the previous entries should be removed (by default they are)
     */
    var _init = function(success, error, rm_previous) {
        var clear = true;
        if (typeof rm_previous === &#x27;boolean&#x27;) {
            clear = rm_previous;
        }

        // initialize connection
        var req = indexedDB.open(_name, _version);

        // update or create db
        req.onupgradeneeded = function() {
            var os;
            console.log(&#x27;db upgrade needed&#x27;);
            EEXCESS.DB = req.result;
            // remove existing object store &#x27;resource_relations&#x27; if present
            if (EEXCESS.DB.objectStoreNames.contains(&#x27;resource_relations&#x27;) &amp;&amp; clear) {
                EEXCESS.DB.deleteObjectStore(&#x27;resource_relations&#x27;);
            }
            // create object store &#x27;resource_relations&#x27;
            os = EEXCESS.DB.createObjectStore(&#x27;resource_relations&#x27;, {keyPath: &#x27;id&#x27;, autoIncrement: true});
            os.createIndex(&#x27;query&#x27;, &#x27;context.query&#x27;);
            os.createIndex(&#x27;resource&#x27;, &#x27;resource&#x27;);
            os.createIndex(&#x27;timestamp&#x27;, &#x27;timestamp&#x27;);


            // remove existing object store &#x27;recommendations&#x27; if present
            if (EEXCESS.DB.objectStoreNames.contains(&#x27;recommendations&#x27;) &amp;&amp; clear) {
                EEXCESS.DB.deleteObjectStore(&#x27;recommendations&#x27;);
            }
            // create object store &#x27;recommendations&#x27;
            os = EEXCESS.DB.createObjectStore(&#x27;recommendations&#x27;, {keyPath: &#x27;recommendation_id&#x27;, autoIncrement: true});
            os.createIndex(&#x27;uri&#x27;, &#x27;uri&#x27;);
            os.createIndex(&#x27;timestamp&#x27;, &#x27;timestamp&#x27;);
            os.createIndex(&#x27;query&#x27;, &#x27;context.query&#x27;);

            // remove existing object store &#x27;tasks&#x27; if present
            if (EEXCESS.DB.objectStoreNames.contains(&#x27;tasks&#x27;) &amp;&amp; clear) {
                EEXCESS.DB.deleteObjectStore(&#x27;tasks&#x27;);
            }

            // remove existing object store &#x27;queries&#x27; if present
            if (EEXCESS.DB.objectStoreNames.contains(&#x27;queries&#x27;) &amp;&amp; clear) {
                EEXCESS.DB.deleteObjectStore(&#x27;queries&#x27;);
            }
            // create object store &#x27;queries&#x27;
            os = EEXCESS.DB.createObjectStore(&#x27;queries&#x27;, {keyPath: &#x27;id&#x27;, autoIncrement: true});
            os.createIndex(&#x27;query&#x27;, &#x27;query&#x27;);
            os.createIndex(&#x27;timestamp&#x27;, &#x27;timestamp&#x27;);


            // remove existing object store &#x27;queries_full&#x27; if present
            if (EEXCESS.DB.objectStoreNames.contains(&#x27;queries_full&#x27;) &amp;&amp; clear) {
                EEXCESS.DB.deleteObjectStore(&#x27;queries_full&#x27;);
            }
            // create object store &#x27;queries_full&#x27;
            os = EEXCESS.DB.createObjectStore(&#x27;queries_full&#x27;, {keyPath: &#x27;id&#x27;, autoIncrement: true});
            os.createIndex(&#x27;query&#x27;, &#x27;query&#x27;);
            os.createIndex(&#x27;timestamp&#x27;, &#x27;timestamp&#x27;);


            // remove existing object store &#x27;history&#x27; if present
            if (EEXCESS.DB.objectStoreNames.contains(&#x27;history&#x27;) &amp;&amp; clear) {
                EEXCESS.DB.deleteObjectStore(&#x27;history&#x27;);
            }
            // create object store &#x27;history&#x27;
            os = EEXCESS.DB.createObjectStore(&#x27;history&#x27;, {keyPath: &#x27;visit_id&#x27;, autoIncrement: true});
            os.createIndex(&#x27;chrome_visitId&#x27;, &#x27;chrome_visitId&#x27;);
            os.createIndex(&#x27;start&#x27;, &#x27;start&#x27;);
            os.createIndex(&#x27;end&#x27;, &#x27;end&#x27;);

            // remove existing object store &#x27;demographics&#x27; if present
            if (EEXCESS.DB.objectStoreNames.contains(&#x27;demographics&#x27;) &amp;&amp; clear) {
                EEXCESS.DB.deleteObjectStore(&#x27;demographics&#x27;);
            }

            // remove existing object store &#x27;interactions&#x27; if present
            if (EEXCESS.DB.objectStoreNames.contains(&#x27;interactions&#x27;) &amp;&amp; clear) {
                EEXCESS.DB.deleteObjectStore(&#x27;interactions&#x27;);
            }
            // create object store &#x27;interactions&#x27;
            os = EEXCESS.DB.createObjectStore(&#x27;interactions&#x27;, {keyPath: &#x27;id&#x27;, autoIncrement: true});
            os.createIndex(&#x27;timestamp&#x27;, &#x27;timestamp&#x27;);
        };

        req.onsuccess = function() {
            _db = req.result;
            if (typeof success === &#x27;function&#x27;) {
                success(req.result);
            }
        };

        req.onerror = function() {
            if (typeof error === &#x27;function&#x27;) {
                error(this);
            }
        };
    };

    var _loadQueryCrumbsData = function(history_length, success, error) {
        _getDB(function(db) {
            var queries = [];

            var tx1 = db.transaction(&quot;queries&quot;);
            var index = tx1.objectStore(&quot;queries&quot;).index(&quot;timestamp&quot;);
            var i = 0;

            index.openCursor(null, &quot;prev&quot;).onsuccess = function(event) {
                var cursor = event.target.result;
                if (cursor &amp;&amp; i &lt; history_length) {
                    queries.push(cursor.value);
                    i += 1;
                    cursor.continue();
                }
            };
            tx1.oncomplete = function(event) {

                var fLoadSuccess = 0;

                var pushResults = function(q) {
                    queries[q].results = [];
                    var tx_sub = db.transaction(&quot;recommendations&quot;);
                    var recIndex = tx_sub.objectStore(&quot;recommendations&quot;).index(&quot;query&quot;);
                    var queryString = &#x27;&#x27;;

                    if(typeof queries[q].query != &quot;undefined&quot;) {
                            queries[q].query.forEach(function(d) {
                     queryString += d.text + &#x27; &#x27;;
                    });
                    }
                      
                    
                    queryString = queryString.trim();
                    queries[q].query = queryString.split(&#x27; &#x27;);
                    var singleKeyRange = IDBKeyRange.only(queryString);
                    recIndex.openCursor(singleKeyRange).onsuccess = function(event) {
                        var cursor2 = event.target.result;
                        if (cursor2) {
                            var result = {
                                title: cursor2.value.result.title,
                                uri: cursor2.value.result.uri
                            };
                            queries[q].results.push(result);
                            cursor2.continue();
                        }
                    };

                    tx_sub.oncomplete = function(event) {
                        fLoadSuccess += 1;
                        if (fLoadSuccess === queries.length) {
                            success(queries);
                        }
                    };
                };

                for (var q = 0; q &lt; queries.length; q++) {
                    pushResults(q);
                }
            };
        }, _empty_callback(error));
    };

    return {
        local: _local,
        put: _put,
        add: _add,
        storeVisit: _storeVisit,
        storeRecommendations: _storeRecommendations,
        getRating: _getRating,
        getRatings: _getRatings,
        setRating: _setRating,
        closedRecommendation: _closedRecommendation,
        loadQueryCrumbsData: _loadQueryCrumbsData
    };
})();

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
