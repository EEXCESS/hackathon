<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>visualizations/Vis-Template/vis.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/EEXCESS.model.common.html">EEXCESS.model.common</a></li>
                                <li><a href="../classes/EEXCESS.model.constants.html">EEXCESS.model.constants</a></li>
                                <li><a href="../classes/EEXCESS.model.interests.html">EEXCESS.model.interests</a></li>
                                <li><a href="../classes/EEXCESS.model.languages.html">EEXCESS.model.languages</a></li>
                                <li><a href="../classes/EEXCESS.model.obfuscation.html">EEXCESS.model.obfuscation</a></li>
                                <li><a href="../classes/EEXCESS.model.policy.html">EEXCESS.model.policy</a></li>
                                <li><a href="../classes/EEXCESS.model.profile.html">EEXCESS.model.profile</a></li>
                                <li><a href="../classes/EEXCESS.model.storage.html">EEXCESS.model.storage</a></li>
                                <li><a href="../classes/EEXCESS.model.util-html.html">EEXCESS.model.util-html</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: visualizations/Vis-Template/vis.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
function Visualization( EEXCESSobj ) {

	var self = this;
	var EEXCESS = EEXCESSobj || {};
	
    var width;		// Screen width
    var height;	    // Screen height
	
    var inputData;

	
    // DOM Selectors
    var root = &quot;div#eexcess_canvas&quot;;											                   // String to select the area where the visualization should be displayed
	var searchField = &quot;#eexcess_search_field&quot;;									                   // String to select search field in the header
	var btnSearch = &quot;#eexcess_search_button&quot;;									                   // Selector for search button on left side of the header
	var headerText = &quot;#eexcess_header_text&quot;;									                   // String to select the text container in the middle of the header
	var btnReset = &quot;#eexcess_btnreset&quot;;											                   // Selector for reset button in vis control panel
	var chartSelect = &quot;#eexcess_select_chart&quot;;									                   // select for chart
	var divMapping = &quot;#eexcess_controls_mappings&quot;;								                   // div that contains selects for mapping combinations
	var divMappingInd = &quot;#eexcess_mapping_container_&quot;;							                   // id for the above div
	var mappingSelect = &quot;.eexcess_select&quot;;										                   // To select all visual channels&#x27; &lt;select&gt; elements by class
	var contentPanel = &quot;#eexcess_content&quot;;										                   // Selector for content div on the right side
	var contentList = &quot;#eexcess_content .eexcess_result_list&quot;;					                   // ul element within div content
	var allListItems = &quot;#eexcess_content .eexcess_result_list .eexcess_list&quot;;	                   // String to select all li items by class
	var listItem = &quot;#eexcess_content .eexcess_result_list #data-pos-&quot;;			                   // String to select individual li items by id
	var colorIcon = &quot;.color_icon&quot;;												                   // Class selector for div icon colored according to legend categories
	var favIconClass = &quot;.eexcess_fav_icon&quot;;                                                        // img element fpr favicon (either on or off)
    var bookmarkDetailsIconClass = &quot;.eexcess_details_icon&quot;;                                        // img element with 3-dot icon in each list item used to display bookmarked item&#x27;s details on click
    var loadingMsgId = &quot;#eexcess_message_on_canvas&quot;;											
	var filterSelect = &quot;#eexcess_header_filter&quot;;												   // String to select in the right of the header

	
    var bookmarkDialogClass = &quot;.eexcess-bookmark-dialog&quot;;                                          // Class selector for both types of dialog: save bookmark and see-and-edit-bookmark
    var saveBookmarkDialogId = &quot;#eexcess-save-bookmark-dialog&quot;;                                    // Id for dialog poping up upon clicking on a &quot;star&quot; icon
    var bookmarkDropdownList = &quot;#eexcess-save-bookmark-dialog .eexcess-bookmark-dropdown-list&quot;;    // Div wrapping drop down list in bookmark dialog
    var newBookmarkOptionsId = &quot;#eexcess-save-bookmark-dialog .eexcess-bookmark-dialog-optional&quot;;  // Div wrapping color picker and input element in bookmark dialog
    var colorPickerId = &quot;#eexcess-bookmak-dialog-color-picker&quot;;                                    // Div tranformed into a colorpicekr in bookmark dialog
    var bookmarkDialogInputWrapper = &quot;#eexcess-save-bookmark-dialog .eexcess-bookmark-dialog-input-wrapper&quot;; // Wrapper for input containing new bookmark name
    var detailsBookmarkDialogId = &quot;#eexcess-see-and-edit-bookmark-dialog&quot;;                         // Dialog displaying bookmark detials (when click on 3-dotted icon)
    var bookmarkedInId = &#x27;eexcess-bookmark-bookmarked-in-&#x27;;                                        // Divs in bookamark details dialog showing bookmarks in which the current item is recorded
	var filterBookmarkDialogId =&quot;#eexcess-filter-bookmark-dialog&quot;;								   // Id for dialog filter bookmark
	var filterBookmarkDropdownList = &quot;#eexcess-filter-bookmark-dialog .eexcess-bookmark-dropdown-list&quot;; // Div wrapping drop down list in filter bookmark dialog
	var deleteBookmark = &quot;#eexcess_deleteBookmark_button&quot;;										   // Button for boookmark deleted.
	var addBookmarkItems = &quot;#eexcess_addBookmarkItems_button&quot;;									   // Button for add boookmarkitems.
	var exportBookmark = &quot;#eexcess_export_bookmark&quot;;											   // Export bookmark data.
	var importBookmark = &quot;#eexcess_import_bookmark&quot;;											   // Import bookmark data.
	var importBookmarkStyle = &quot;#eexcess_import_bookmark_style&quot;;									   // Styles import bookmark button control.
	// Icon &amp; Image Constants
	var LOADING_IMG = &quot;../../media/loading.gif&quot;;
	var NO_IMG = &quot;../../media/no-img.png&quot;;
    var FAV_ICON_OFF = &quot;../../media/icons/favicon_off.png&quot;;
    var FAV_ICON_ON = &quot;../../media/icons/favicon_on.png&quot;;
    var REMOVE_SMALL_ICON = &quot;../../media/batchmaster/remove.png&quot;;
    var BOOKMARK_DETAILS_ICON = &quot;../../media/batchmaster/ellipsis.png&quot;;
    var IMG_COLOR_WHEEL_LARGE = &quot;../../media/color-spectrum.jpg&quot;;
    var IMG_COLOR_WHEEL_MEDIUM = &quot;../../media/color-wheel.jpg&quot;;
    var ICON_EUROPEANA =  &quot;../../media/icons/Europeana-favicon.ico&quot;;
    var ICON_MENDELEY = &quot;../../media/icons/mendeley-favicon.ico&quot;;
    var ICON_ZBW = &quot;../../media/icons/ZBW-favicon.ico&quot;;
    var ICON_WISSENMEDIA = &quot;../../media/icons/wissenmedia-favicon.ico&quot;;
    var ICON_KIM_COLLECT = &quot;../../media/icons/KIM.Collect-favicon.ico&quot;;
	var ICON_UNKNOWN = &quot;../../media/icons/help.png&quot;;

    // String Constants
    var STR_LOADING = &quot;Loading...&quot;;
    var STR_NO_DATA_RECEIVED = &quot;No Data Received&quot;;
    var STR_NEW = &quot;New Collecction...&quot;;
	var STR_BOOKMARK_NAME_MISSING = &quot;Indicate new bookmark name&quot;;
	var STR_SHOWALLRESULTS = &quot;Search results&quot;;

	
	// Main variables
	var data;							// contains the data to be visualized
	var mappings;						// contains all the possible mapping combiantions for each type of visualization
	var query;							// string representing the query that triggered the current recommendations
	var charts;
	var groupBy;
	
	
	// Ancillary variables
	var visChannelKeys;					// array containing the keys (names) of the visual atributes corresponding to the current chart
	var mappingSelectors;			    // Selector array for visual channel &lt;select&gt;. Necessary for event handlers
	var indicesToHighlight = [];	    // array containing the indices of &lt;li&gt; elements to be highlighted in content list
	var isBookmarkDialogOpen;
    //var idsArray;
    var bookmarkedItems;

	// Chart objects
	var timeVis, barVis, geoVis;




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     *  START object is returned to starter so it can call init or redresh upon new results received
     *
     */

    var START = {};

	/**
	 * 	Initizialization function called from starter.js
	 * 	Sets up the visualization-independent components and instantiates the visualization objects (e.g. timeVis)
	 *
	 * */
	START.init = function(){

		PREPROCESSING.bindEventHandlers();
		timeVis = new Timeline(root, EXT);
		barVis = new Barchart(root, EXT);
        geoVis = new Geochart(root, EXT);

        BookmarkingAPI = new Bookmarking();
        BookmarkingAPI.init();

        VISPANEL.clearCanvasAndShowMessage( STR_LOADING );
        $(window).on(&#x27;resize&#x27;, function(){ VISPANEL.drawChart(); });

        // for Debugging Purposes
        //$(searchField).val(&#x27;Graz&#x27;);
        //QUERY.refreshResults();
        //$(chartSelect).val(&quot;geochart&quot;);
        //VISPANEL.drawChart();
	};




    /**
     * 	Initizialization function called from starter.js
     * 	Sets up the visualization-independent components and instantiates the visualization objects (e.g. timeVis)
     *
     * */
    START.refresh = function(input){

        if(typeof input == &#x27;undefined&#x27; || input == &#x27;undefined&#x27;){
            VISPANEL.clearCanvasAndShowMessage( STR_NO_DATA_RECEIVED );
            return;
        }

        width  = $(window).width();
        height = $(window).height();

        data = input.data; //receivedData;													// contains the data to be visualized
        charts = input.charts; //receivedCharts;
        mappings = input.mappingcombination; //PREPROCESSING.getFormattedMappings( receivedMappings );		// contains all the possible mapping combiantions for each type of visualization
        query = input.query;													// string representing the query that triggered the current recommendations

        // Initialize template&#x27;s elements
        PREPROCESSING.setAncillaryVariables();
        BOOKMARKS.updateBookmarkedItems();
        PREPROCESSING.extendDataWithAncillaryDetails();
        QUERY.updateHeaderText( &quot;Query Results : &quot; + data.length );
        QUERY.updateSearchField( query );
        CONTROLS.buildChartSelect();
        LIST.buildContentList();
		FILTER.buildFilterBookmark();
		BOOKMARKS.exportBookmarks();
		BOOKMARKS.importBookmarks();
		
        // Call method to create a new visualization (empty parameters indicate that a new chart has to be drawn)
        VISPANEL.drawChart();


        //BookmarkingAPI.testBookmarking();
    };




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	var PREPROCESSING = {};
	
	
	/**
	 *	Bind event handlers to buttons
	 *$
	 * */
	PREPROCESSING.bindEventHandlers = function(){
		$( btnSearch  ).click( function(){ EVTHANDLER.btnSearchClicked(); });
		$( searchField ).on(&#x27;keypress&#x27;, function(e){ if (e.keyCode == 13) EVTHANDLER.btnSearchClicked(); });
		$( btnReset   ).click( function(){ EVTHANDLER.btnResetClicked(); });
        $( &#x27;html&#x27; ).click(function(){ if(isBookmarkDialogOpen) BOOKMARKS.destroyBookmarkDialog(); });
	};
	


	
	/**
	 * Format the received mapping combinations so they can be more easily manipulated
	 * 
	 **/
	PREPROCESSING.getFormattedMappings = function( originalMappings ){
		
		formattedMappings = [];
			
		charts.forEach(function(chart, chartIndex){
			
			// formattedMappings[].combinations is a 2D array containing all the possible combinations for each chart
			// outer array =&gt; 1 mapping combination per element. Inner array =&gt; 1 visual channel/attribute per element
			formattedMappings.push({ &#x27;chart&#x27;: chart, &#x27;combinations&#x27;: new Array() });		
			var keys = [];
			
			// Find in the mappings received the first mapping combination for the current chart
			var firstIndex = 0;
			while(firstIndex &lt; originalMappings.length &amp;&amp; originalMappings[firstIndex].chartname != chart)
				firstIndex++;
			
			// Find the visual channels&#x27; keys for the current chart
			originalMappings[firstIndex].visualchannels.forEach(function(vc){
				keys.push(vc.label);
			});
			
			// Find all the mapping combinations for the current chart, starting from firstIndex
			//(it&#x27;s already known that the previous mappings are not for current chart)
			for(var i = firstIndex; i &lt; originalMappings.length; i++){
				
				if(originalMappings[i].chartname == chart){
					
					//	Mapping combination found. Add new array element to formattedMappings[].combinations[] array   
					var combIndex = formattedMappings[chartIndex].combinations.length;		
					formattedMappings[chartIndex].combinations[combIndex] = new Array();
					
					originalMappings[i].visualchannels.forEach(function(vc){
					
						var visChannel = {&#x27;facet&#x27;: vc.component.facet, &#x27;visualattribute&#x27;: vc.label};
						var vcIndex = keys.indexOf(vc.label);
						
						formattedMappings[chartIndex].combinations[combIndex][vcIndex] = visChannel;
					});
				}
			}
		});

		formattedMappings = PREPROCESSING.dirtyFixForMappings(formattedMappings);	// once fixed in server delete this line and the method
		return formattedMappings;
	};
	
	
	PREPROCESSING.dirtyFixForMappings = function(formattedMappings){

		var i = formattedMappings.getIndexOf(&quot;barchart&quot;, &quot;chart&quot;);
		if (i != -1)
            formattedMappings.splice(i, 1);
		
		i = formattedMappings.push( {&#x27;chart&#x27;: &#x27;barchart&#x27;, &#x27;combinations&#x27;: new Array()} );
        i--;
		charts.push(&#x27;barchart&#x27;);
		
		var facets = [&#x27;language&#x27;, &#x27;provider&#x27;];
		facets.forEach(function(facet){
			var combIndex = formattedMappings[i].combinations.length;
			formattedMappings[i].combinations[combIndex] = new Array();
			formattedMappings[i].combinations[combIndex].push( {&#x27;facet&#x27;: facet, &#x27;visualattribute&#x27;: &#x27;x-axis&#x27;} );
			formattedMappings[i].combinations[combIndex].push( {&#x27;facet&#x27;: &#x27;count&#x27;, &#x27;visualattribute&#x27;: &#x27;y-axis&#x27;} );
			formattedMappings[i].combinations[combIndex].push( {&#x27;facet&#x27;: facet, &#x27;visualattribute&#x27;: &#x27;color&#x27;} );
		});
		
        i = formattedMappings.getIndexOf(&quot;geochart&quot;, &quot;chart&quot;);
        if (i != -1)
            formattedMappings.splice(i, 1);

        i = formattedMappings.push( {&#x27;chart&#x27;: &#x27;geochart&#x27;, &#x27;combinations&#x27;: new Array()} );
        i--;
        charts.push(&#x27;geochart&#x27;);
        facets.forEach(function(facet){
            var combIndex = formattedMappings[i].combinations.length;
            formattedMappings[i].combinations[combIndex] = new Array();
            formattedMappings[i].combinations[combIndex].push( {&#x27;facet&#x27;: facet, &#x27;visualattribute&#x27;: &#x27;color&#x27;} );
        });

		return formattedMappings;
	};

	

    PREPROCESSING.setAncillaryVariables = function() {
	    //indicesToHighlight = [];
        isBookmarkDialogOpen = false;
        //idsArray = data.map(function(d){ return d.id; });//not used
    };





    PREPROCESSING.extendDataWithAncillaryDetails = function(){

        data.forEach(function(d){

            // Set &#x27;bookmarked&#x27; property to true or false
            if(typeof bookmarkedItems[d.id] != &#x27;undefined&#x27; &amp;&amp; bookmarkedItems[d.id] != &#x27;undefined&#x27;)
                d[&#x27;bookmarked&#x27;] = true;
            else
                d[&#x27;bookmarked&#x27;] = false;


            // Assign &#x27;provider-icon&#x27; with the provider&#x27;s icon
            switch(d.facets.provider){
                case &quot;europeana&quot;:
                case &quot;Europeana&quot;:   d[&#x27;provider-icon&#x27;] = ICON_EUROPEANA; break;
			    case &quot;mendeley&quot;:    d[&#x27;provider-icon&#x27;] = ICON_MENDELEY; break;
                case &quot;econbiz&quot;:
                case &quot;ZBW&quot;:         d[&#x27;provider-icon&#x27;] = ICON_ZBW; break;
                case &quot;wissenmedia&quot;: d[&#x27;provider-icon&#x27;] = ICON_WISSENMEDIA; break;
                case &quot;KIM.Collect&quot;: d[&quot;provider-icon&quot;] = ICON_KIM_COLLECT; break;
                default:            d[&#x27;provider-icon&#x27;] = ICON_UNKNOWN; break;
            }
        });

    };


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	var QUERY = {};
	
	/**
	 *	Updates the text in the center of the header according to the received paramter 
	 *
	 * */
	QUERY.updateHeaderText = function( text ){
		
		if( text == STR_LOADING){
			$( headerText ).find( &quot;span&quot; ).text( &quot;&quot; );
            
            VISPANEL.clearCanvasAndShowMessage( STR_LOADING );
		}
		else{
			$( headerText ).find( &quot;span&quot; ).text( text );
		}
	};
	
	/**
	 * Updates search field on the header (on left side for the moment)
	 * 
	 **/
	QUERY.updateSearchField = function( text, action ){
		$( searchField ).attr( &quot;value&quot;, text );
	};
	
	
	QUERY.refreshResults = function(){
		var terms = $( searchField ).val();
		
		// Search for new results if the query is different from the current one
		if(terms != query){
			this.updateHeaderText( STR_LOADING );
            EEXCESS.messaging.callBG({method: {parent: &#x27;model&#x27;, func: &#x27;query&#x27;}, data: {terms:[{weight:1,text:terms}],reason:{reason:&#x27;manual&#x27;}}});
		}
	};

	
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	var EVTHANDLER = {};


	/**
	 * Click on search button triggers a new search
	 * 
	 * */
	EVTHANDLER.btnSearchClicked = function(){
		QUERY.refreshResults();
	};

	
	/**
	 * 	Chart &lt;select&gt; changed
	 * 
	 * */
	EVTHANDLER.chartSelectChanged = function(){
		VISPANEL.drawChart();
	};
	
	
	/**
	 *	Function that wraps the change event handlers. These events are triggered by the &lt;select&gt; elements (chart and visual channels)
	 *
	 * */
	EVTHANDLER.setSelectChangeHandlers = function(){
		// Change event handler for visual channels&#x27; &lt;select&gt; elements
		$(mappingSelectors).each(function(i, item){	

            if($(item).attr(&#x27;isDynamic&#x27;).toBool())
                $(item).change(function(){
				    VISPANEL.drawChart( item );
			 });
		});
		
	};
	
	
	////////	content list item click	////////
	
	EVTHANDLER.listItemClicked = function(d, i, isSelectedFromOutside, x, y, z){
		if (d3.event.ctrlKey){
        	LIST.selectListItem( d, i, false, true);
		} else {
        	LIST.selectListItem( d, i);
    	}
	};
	

	
	
	////////	Reset Button Click	////////
	
	EVTHANDLER.btnResetClicked = function(){
		indicesToHighlight = VISPANEL.getAllSelectListItems();
	
		LIST.highlightListItems(indicesToHighlight);
		//$(filterBookmarkDialogId+&quot;&gt;div&gt;span&quot;).text(STR_SHOWALLRESULTS);
		//$(filterBookmarkDialogId+&quot;&gt;div&gt;div&quot;).css(&quot;background&quot;,&quot;inherit&quot;);
		//$(deleteBookmark).prop(&quot;disabled&quot;,true);
		
		//FILTER.showStars();	
		//FILTER.updateData();	
		
		VISPANEL.updateCurrentChart( &quot;reset_chart&quot; );
		
	};


    /**** Bookmark section in content list items ****/

	////////	Star Icon clicked on list item    ////////

    EVTHANDLER.faviconClicked = function(d, i){

        d3.event.stopPropagation();
        //BOOKMARKS.buildSaveBookmarkDialog(d, i, this);//ask cecillia ????????
		BOOKMARKS.buildSaveBookmarkDialog(
            d,
			function(thisValue){
				thisValue.internal.setCurrentItem(d, i);
			},
			function(bookmarkDetails){
				bookmarkDetails.append(&#x27;p&#x27;).text(d.title);
			},EVTHANDLER.bookmarkSaveButtonClicked,
			this);
    };



    EVTHANDLER.bookmarkDetailsIconClicked = function(d, i){

        d3.event.stopPropagation();
        BOOKMARKS.buildSeeAndEditBookmarkDialog(d, i);
    };



    /**** Bookmark Dialog ****/

    ////////	Value changed in bookmark dropdown list 	////////
    EVTHANDLER.bookmarkDropdownListChanged = function(value, index){
		
		currentSelectIndex = index;
		//console.log(&quot;##### &gt;&gt; &quot; +currentSelectIndex);
	
        if(index == 0)
            $(newBookmarkOptionsId).slideDown(&quot;slow&quot;);
        else
            $(newBookmarkOptionsId).slideUp(&quot;slow&quot;);

        $(newBookmarkOptionsId).find(&#x27;p&#x27;).fadeOut(&#x27;fast&#x27;);      // error message hidden
    };


    ////////	&#x27;Cancel&#x27; button clicked in save bookmark dialog 	////////
    EVTHANDLER.bookmarkCancelButtonClicked = function(){
        BOOKMARKS.destroyBookmarkDialog();
    };


    ////////	&#x27;Save&#x27; button clicked in save bookmark dialog 	////////
    EVTHANDLER.bookmarkSaveButtonClicked = function(){
        BOOKMARKS.saveBookmark();
		FILTER.changeDropDownList();
    };


    ////////	&#x27;Done&#x27; button clicked in bookmark details dialog 	////////
    EVTHANDLER.bookmarkDoneButtonClicked = function(){
        BOOKMARKS.destroyBookmarkDialog();
    };



    EVTHANDLER.removeBookmarkIconClicked = function(bookmark, bookmarkIndex) {
        BOOKMARKS.deleteBookmarkAndRefreshDetailsDialog(this, bookmark, bookmarkIndex);
    }


	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	var CONTROLS = {}
	
	/**
	 * Creates the &lt;select&gt; element to chose the type of visualization (chart)
	 * 
	 * */
	CONTROLS.buildChartSelect = function(){
		
		//Create chart &lt;select&gt;
		var chartOptions = &quot;&quot;;
		
		// &quot;mappings&quot; is an array where each item contains the name of the chart and all the possible combinatios for it 
		charts.forEach(function(chart){ 
			chartOptions += &quot;&lt;option class=\&quot;ui-selected\&quot; value=\&quot;&quot; + chart + &quot;\&quot;&gt;&quot; + chart + &quot;&lt;/option&gt;&quot;; 
		});
		
		d3.select(chartSelect).html(chartOptions);
		$(chartSelect+&quot;:eq(&quot;+ 0 +&quot;)&quot;).prop(&quot;selected&quot;, true);
		
		$(chartSelect).change( EVTHANDLER.chartSelectChanged );
	};
		
	
	
	/**
	 *	Created one &lt;select&gt; element per visual channel
	 *	It is executed every time the chart selection changes
	 *
	 * */	
	CONTROLS.buildVisualChannelSelects = function(){

		// Steps to create &lt;select&gt; elements for visual channels
		//
		var combinations = [];
        var initialMapping = [];
		var chartIndex = charts.indexOf( VISPANEL.chartName );		// VISPANEL.chartName value assigned in &#x27;getSelectedMapping()&#x27; (the caller)
		mappingSelectors = [];
		
		visChannelKeys = [];

        if(mappings[chartIndex].combinations.length &gt; 0){

            initialMapping = mappings[chartIndex].combinations[0];
		
            // Each item of the array &quot;combinations&quot; consists in an object that stores the name of the visual channel (&#x27;channel&#x27;),
            // and an empty array that will contain all its possible values (&#x27;values&#x27;)
            initialMapping.forEach(function(m){
                combinations.push({&#x27;channel&#x27;: m.visualattribute, &#x27;values&#x27;: []});
                visChannelKeys.push(m.visualattribute);
            });
				
            // Goes over all the combinations. Every time chartname equals the current chart, it retrieves all the possible values for each visual channel
            // The values are stored like -&gt; combinations[0] = { channel: x-axis, values: [year, ...]}
            mappings[chartIndex].combinations.forEach(function(comb){
			
                comb.forEach(function(vc){
				    var visAttrIndex = visChannelKeys.indexOf(vc.visualattribute);
				
                    if(combinations[visAttrIndex][&#x27;values&#x27;].indexOf(vc.facet) == -1)
					   combinations[visAttrIndex][&#x27;values&#x27;].push(vc.facet);
                });
					
            });
		
            // For each visual channel stored in the array combinations, creates a &lt;select&gt; element and populates its &lt;option&gt; subitems with the
            // values retrieved in the previous step
            combinations.forEach(function(c, i){
			
                var divChannel = d3.select(divMapping)
				    .append(&quot;div&quot;)
					.attr(&quot;class&quot;, &quot;eexcess_mapping_container&quot;)
					.attr(&quot;id&quot;, &quot;eexcess_mapping_container_&quot;+i);
			
                divChannel
				    .append(&quot;span&quot;)
				    .attr(&quot;class&quot;, &quot;eexcess_controls_title&quot;)
				    .text(c.channel);
			
                var selector;
                if(c.values.length &gt; 1){

                    var channelSelect = divChannel
				        .append(&quot;select&quot;)
                            .attr(&quot;class&quot;, &quot;eexcess_select&quot;)
					        .attr(&quot;name&quot;, c.channel)
                            .attr(&#x27;isDynamic&#x27;, true);
			
                    var mappingOptions = &quot;&quot;;

                    c.values.forEach(function(v){
				        mappingOptions += &quot;&lt;option class=\&quot;ui-selected\&quot; value=\&quot;&quot;+v+&quot;\&quot;&gt;&quot;+v+&quot;&lt;/option&gt;&quot;;
                    });
                    channelSelect.html( mappingOptions );

                    selector = mappingSelect; // string for selecting a visual channel &lt;select&gt; element
                }
                else{
                    divChannel.append(&#x27;div&#x27;)
                        .attr(&#x27;class&#x27;, &#x27;eexcess_controls_facet_static&#x27;)
                        .attr(&#x27;name&#x27;, c.channel)
                        .attr(&#x27;isDynamic&#x27;, false)
                        .text(c.values[0]);
                    selector = &quot;.eexcess_controls_facet_static&quot;;
                }

                // the &quot;mappingSelectors&quot; array stores the selectors that allow to set change events for each visual channel &lt;select&gt; element in
                // the function &quot;setSelectChangeHandlers&quot;
                // E.g. mappingSelectors[0] = &quot;#eexcess_mapping_container_0 .eexcess_select&quot;
                mappingSelectors.push(divMappingInd + &quot;&quot; + i + &quot; &quot;+ selector);
            });


            // Create event handlers
            EVTHANDLER.setSelectChangeHandlers();
		
        }
		return initialMapping;
	};
	
	
	
	/**
	 *	Update visual channels&#x27; &lt;select&gt; elements according to mapping combination received as parameter
	 *
	 * */
	CONTROLS.updateChannelsSelections = function( validMapping ){

		$(mappingSelectors).each(function(i, item){
			var channelName= $(item).attr(&quot;name&quot;);
			var channelIndex = visChannelKeys.indexOf(channelName);
			$(item + &quot; option[value=&quot;+validMapping[channelIndex].facet+&quot;]&quot;).prop(&quot;selected&quot;, true);
		});
	}
	



	
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	var LIST = {};

	LIST.indicesSelected = [];
	
	LIST.internal = {
			
			/**
			 *	Calculates the index to scroll to, which depends on the existence or abscence of a ranking
			 *	There exists a ranking if dataRanking.length &gt; 0
			 * */
			getIndexToScroll: function( indices ) {	
				if( typeof dataRanking === &#x27;undefined&#x27; || dataRanking === &#x27;undefined&#x27; || dataRanking.length &gt; 0){
					for(var i = 0; i &lt; dataRanking.length; i++){
						if( indices.indexOf( dataRanking[i].originalIndex ) !== -1 )
							return dataRanking[i].originalIndex;
					}
				}
				else
					return indices[0];
			}
	};
			
	
	/**
	 *	Function that populates the list on the right side of the screen.
	 *	Each item represents one recommendation contained in the variable &quot;data&quot;
	 *
	 * */	
	LIST.buildContentList = function(){
	
		//d3.selectAll(&quot;.eexcess_ritem&quot;).remove();
		d3.selectAll( allListItems ).remove();
		
		var listData = d3.select(contentList).selectAll(&quot;li&quot;).data(data);
		
		var aListItem = listData.enter()
							.append(&quot;li&quot;)
								.attr(&quot;class&quot;, &quot;eexcess_list&quot;)
								.attr(&quot;id&quot;, function(d, i){ return &quot;data-pos-&quot;+i; })
								.on(&quot;click&quot;, EVTHANDLER.listItemClicked);
		
		// div 1 groups the preview image, partner icon and link icon
		iconsDiv = aListItem.append(&quot;div&quot;)
					.attr(&quot;class&quot;, &quot;eexcess_item_ctl&quot;);
		
		iconsDiv.append(&quot;a&quot;)
				.attr(&quot;href&quot;, &quot;#&quot;)
				.append(&quot;img&quot;)
					.attr(&quot;class&quot;, &quot;eexcess_preview&quot;)
					.attr(&quot;src&quot;, function(d){ return d.previewImage || NO_IMG ; });
		
		iconsDiv.append(&quot;img&quot;)
				.attr(&quot;class&quot;, &quot;eexcess_partner_icon&quot;)
				.attr(&quot;title&quot;, function(d){ return d.facets.provider; })
				.attr(&quot;src&quot;, function(d){ return d[&#x27;provider-icon&#x27;]; });


		// div 2 wraps the recommendation title (as a link), a short description and a large description (not used yet)
		var contentDiv = aListItem.append(&quot;div&quot;)
			.attr(&quot;class&quot;, &quot;eexcess_ritem_container&quot;);
		

        contentDiv.append(&quot;h1&quot;)
				.append(&quot;a&quot;)
					.attr(&quot;class&quot;, &quot;eexcess_ritem_title&quot;)
					.attr(&quot;href&quot;, function(d){return d.uri;})
                    .on(&quot;click&quot;, function(d){
                        d3.event.preventDefault();
                        d3.event.stopPropagation();
                        window.open(d.uri, &#x27;_blank&#x27;);
                        EEXCESS.messaging.callBG({method:{parent:&#x27;model&#x27;,func:&#x27;resultOpened&#x27;},data:d.uri}); })
					.text(function(d){ return d.title; });


		contentDiv.append(&quot;p&quot;)
			.attr(&quot;class&quot;, &quot;eexcess_ritem_short&quot;)
			.html(function(d){
				var facetKeys = Object.keys(d.facets);
				var string = &quot;&quot;;
				
				facetKeys.forEach(function(facetKey){
					if( !Array.isArray(d.facets[facetKey]) )
						string += d.facets[facetKey] + &quot;, &quot;;
				});
				return string.substring(0, string.length - 2); 
			});

        // bookmark section contains fav icon and details icon

        var bookmarkDiv = aListItem.append(&#x27;div&#x27;)
            .attr(&#x27;class&#x27;, &#x27;eexcess_bookmark_section&#x27;);


        bookmarkDiv.append(&quot;img&quot;)
            .attr(&quot;class&quot;, &quot;eexcess_fav_icon&quot;)
            .attr(&#x27;title&#x27;, &#x27;Bookmark this item&#x27;)
            .attr(&quot;src&quot;, function(d){ if(d.bookmarked) return FAV_ICON_ON; return FAV_ICON_OFF; })
            .on(&quot;click&quot;, EVTHANDLER.faviconClicked);


        //bookmarkDiv.append(&quot;img&quot;)
        //    .attr(&quot;class&quot;, &quot;eexcess_details_icon&quot;)
        //    .attr(&#x27;title&#x27;, &#x27;View and delete item\&#x27;s bookmarks&#x27;)
        //    .attr(&quot;src&quot;, BOOKMARK_DETAILS_ICON)
        //    .style(&quot;display&quot;, function(d){ if(d.bookmarked) return &#x27;inline-block&#x27;; return &#x27;none&#x27;; })
        //    .on(&quot;click&quot;, EVTHANDLER.bookmarkDetailsIconClicked);


		$( contentPanel ).scrollTo( &quot;top&quot; );
	};
	
	
	
	/**
	 * Draws legend color icons in each content list item
	 * */
	LIST.setColorIcon = function(){
		
		$( colorIcon ).remove();
		
		var iconColorScale = (VISPANEL.chartName == &#x27;timeline&#x27;) ?  timeVis.colorScale : (VISPANEL.chartName == &#x27;barchart&#x27;) ?  barVis.colorScale : &#x27;undefined&#x27;; 
		
		if( iconColorScale != &#x27;undefined&#x27; ){
			
			var facet;
			for(var i = 0; i &lt; mappingSelectors.length; i++){
				if($(mappingSelectors[i]).attr(&quot;name&quot;) == &quot;color&quot;)
					facet = $(mappingSelectors[i]).val();
			}
			
			for(var i = 0; i &lt; data.length; i++){	
				var item = $(listItem +&quot;&quot;+ i + &quot; .eexcess_item_ctl&quot;);
				var title = data[i].facets[facet] || &#x27;en&#x27;;
				item.append( &quot;&lt;div class=\&quot;color_icon\&quot; title=\&quot;&quot;+ title +&quot;\&quot; &gt;&lt;/div&gt;&quot; );	
				item.find( colorIcon ).css( &#x27;background&#x27;, iconColorScale(data[i].facets[facet] || &#x27;en&#x27;) );
			}
		}
	};
	
	
	/**
	 * Draws legend color icons in each content list item
	 * */
	LIST.selectListItem = function( d, i, flagSelectedOutside, addItemToCurrentSelection ){
		
		var addItemToCurrentSelection = addItemToCurrentSelection || false;
		var isSelectedFromOutside = flagSelectedOutside || false;
		var index = i;
		var indicesToHighlight = [];

		var indexWasAlreadySelected = LIST.indicesSelected.indexOf(index) &gt; -1;

		if (addItemToCurrentSelection)
			indicesToHighlight = LIST.indicesSelected;

		if (indexWasAlreadySelected)
			indicesToHighlight.splice(indicesToHighlight.indexOf(index), 1);
		else
			indicesToHighlight.push(index);

		LIST.indicesSelected = indicesToHighlight;
		if (indicesToHighlight.length == 0)
			indicesToHighlight = VISPANEL.getAllSelectListItems();
				
		LIST.highlightListItems( indicesToHighlight );
		
		if( !flagSelectedOutside )
			VISPANEL.updateCurrentChart( &#x27;highlight_item_selected&#x27;, indicesToHighlight );
	};
	


	
	/**
	 *	Function that highlights items on the content list, according to events happening on the visualization.
	 *	E.g. when one or more keywords are selected, the matching list items remain highlighted, while the others become translucid
	 *	If no parameters are received, all the list items are restored to the default opacity 
	 *
	 * */
	LIST.highlightListItems = function( indices ){

		// &quot;indices&quot; is an array indicating the indices of the list items that should be highlighted 
		indicesToHighlight =[];
		var highlightIndices = indices || [];
		
		if(highlightIndices.length &gt; 0){
			
			for(var i = 0; i &lt; data.length; i++){			
				var item = d3.select(listItem +&quot;&quot;+ i);
				
				if(highlightIndices.indexOf(i) != -1){
					item.style(&quot;opacity&quot;, &quot;1&quot;);
					indicesToHighlight.push(i);
				}else{
					item.style(&quot;opacity&quot;, &quot;0.2&quot;);
				}
			}

			var indexToScroll = highlightIndices[0];			
			$( contentPanel ).scrollTo( listItem +&quot;&quot;+ indexToScroll );
		}
		else{
			indicesToHighlight = [];
			//change code !!!!!!!!!!!!!
			d3.selectAll( allListItems ).style(&quot;opacity&quot;, &quot;0.2&quot;);
			//d3.selectAll( allListItems ).style(&quot;opacity&quot;, &quot;1&quot;);
			$( contentPanel ).scrollTo( &quot;top&quot; );
		}
	};
	
	

    LIST.turnFaviconOnAndShowDetailsIcon = function( index ){
        // Replace favicon_off with favicon_on
        d3.select(listItem + &#x27;&#x27; +index).select(favIconClass).transition().attr(&quot;src&quot;, FAV_ICON_ON).duration(2000);
        // show bookmark details icon
        $(listItem + &#x27;&#x27; +index + &#x27; &#x27; + bookmarkDetailsIconClass).fadeIn(&#x27;slow&#x27;);
		
		data[index].bookmarked = true;
		
    };


    LIST.turnFaviconOffAndHideDetailsIcon = function( index ){
        // Replace favicon_on with favicon_off
        d3.select(listItem + &#x27;&#x27; +index).select(favIconClass).transition().attr(&quot;src&quot;, FAV_ICON_OFF).duration(2000);
        // Hide bookmark details icon
        $(listItem + &#x27;&#x27; +index + &#x27; &#x27; + bookmarkDetailsIconClass).fadeOut(&#x27;slow&#x27;);
        // Update item&#x27;s property &#x27;bookmarked&#x27;
		
		data[index].bookmarked = false;
    }

	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	var VISPANEL = {};
	
	
	VISPANEL.internal = {
			
        /**
         * Sets the chart and the mapping combination to be used, acording to the &lt;select&gt; elements&#x27; selected values
         * */
        getSelectedMapping: function( item ) {

            // if &quot;item&quot; is undefined -&gt; change triggered by chart &lt;select&gt;, otherwise triggered by one  of the visual channels&#x27; &lt;select&gt;
            var changedItem = item || &quot;undefined&quot;;

            // if the chart changes, reset array with indices to be  highlighted
            if(VISPANEL.chartName != $(chartSelect).val()){//??????????
                //indicesToHighlight = [];
			}
				
            VISPANEL.chartName = $(chartSelect).val();

            var selectedMapping = [];

            if(changedItem == &quot;undefined&quot;){
                // VISPANEL SELECTION CHANGED
                // Empty current visual channels controls (&lt;select&gt; elements)
                $(divMapping).empty();

                // Re-build visual channels&#x27; controls
                // Assign &quot;selectedMapping&quot; with the first possible mapping combination for the new chart, which is returned by the function below
                var selectedMapping = CONTROLS.buildVisualChannelSelects();
            }
            else{
                // VISUAL CHANNEL SELECTION CHANGED
                // Update modified visual channel with new value
                mappingSelectors.forEach(function(item){
                    var channelName = $(item).attr(&quot;name&quot;);
                    var channelValue = $(item).attr(&#x27;isDynamic&#x27;).toBool() ? $(item).val() : $(item).text();
                    selectedMapping.push({&#x27;facet&#x27;: channelValue, &#x27;visualattribute&#x27;: channelName});
                });

                var changedChannelName = $(changedItem).attr(&quot;name&quot;);
                var changedChannelValue = $(changedItem).val();

                // selectedMapping remains unchanged if it contains a valid mapping combination, otherwise it&#x27;s updated with the first valid one in the list
                selectedMapping = this.getValidatedMappings(selectedMapping, changedChannelName, changedChannelValue);
            }

            return selectedMapping;
        },


        /**
         * Checks if the mapping combination is valid. If not, it returns a valid one and calls
         * the method to change the visual attributes&#x27; selected values in the corresponding &lt;select&gt; elements
         *
         * */
        getValidatedMappings: function( selectedMapping, changedChannelName, changedChannelValue ) {

            var validMapping = [];
            var chartIndex = charts.indexOf( VISPANEL.chartName );

            // Go over each mapping combination and and then over each visual channel for the current mapping combination
            for(var combIndex = 0; combIndex &lt; mappings[chartIndex].combinations.length; combIndex++) {

                var flagIsValid = true;
                var j = 0;

                // 	Check each visual channel
                while( j &lt; visChannelKeys.length &amp;&amp; flagIsValid ){
                    var vcIndex = visChannelKeys.indexOf(mappings[chartIndex].combinations[combIndex][j][&#x27;visualattribute&#x27;]);
                    if(mappings[chartIndex].combinations[combIndex][vcIndex][&#x27;facet&#x27;] != selectedMapping[vcIndex][&#x27;facet&#x27;])
                        flagIsValid = false;
                    j++;
                }
                // As soon as the selected combination is validated, return it
                if(flagIsValid)
                    return selectedMapping;

                var validMappingFound = false;
                var changedIndex = visChannelKeys.indexOf(changedChannelName);
                if(mappings[chartIndex].combinations[combIndex][changedIndex][&#x27;facet&#x27;] == changedChannelValue &amp;&amp; !validMappingFound){
                    validMapping = mappings[chartIndex].combinations[combIndex];
                    validMappingFound = true;
                }
            }
            // if loop finishes it means the selectedMapping isn&#x27;t valid
            // Change &lt;select&gt; values according to the first valid mapping combination encountered (stored in validMapping)
            CONTROLS.updateChannelsSelections(validMapping);

            // Return valid combination
            return validMapping;
        }
					
	};

	
	/** 
	 * 	chartName = name of the chart currently displayed
	 * 
	 * */
	VISPANEL.chartName = &quot;&quot;;
	
	
	
	/**
	 * Clears the visualization and specific controls areas.
	 * Retrieves the selected chart and the appropriate mapping combination
	 * Calls the &quot;draw&quot; function corresponding to the selected chart
	 * 
	 * */
	VISPANEL.drawChart = function( item ){
		
		$(root).empty();
		var selectedMapping = this.internal.getSelectedMapping( item );

		switch(VISPANEL.chartName){		// chartName is assigned in internal.getSelectedMapping() 
			case &quot;timeline&quot; : timeVis.draw(data, selectedMapping, width, height); break;
			case &quot;barchart&quot;:  barVis.draw(data, selectedMapping, width, height); break;
            case &quot;geochart&quot;:  geoVis.draw(data, selectedMapping, width, height); break;
			default : d3.select(root).text(&quot;No Visualization&quot;);	
		}

		LIST.setColorIcon();
		LIST.highlightListItems(VISPANEL.getAllSelectListItems());//(indicesToHighlight); //changecode
	};
	
	
	VISPANEL.getAllSelectListItems = function(){
		var array =[];
		data.forEach(function(element,index){
			array.push(index);
		});
		return array;
	};
	
	VISPANEL.updateCurrentChart = function( action, arg ){
		
		switch( action ){
			
			case &quot;reset_chart&quot;:
			
				switch(VISPANEL.chartName){
					case &quot;timeline&quot;: timeVis.reset(); break;
					case &quot;barchart&quot;: barVis.reset(); break;
                    case &quot;geochart&quot;: geoVis.reset(); break;
				}
				break;
			case &quot;highlight_item_selected&quot;:
				
				var arrayIndices = arg;
				switch(VISPANEL.chartName){
					case &quot;timeline&quot;: timeVis.selectNodes(arrayIndices, self); break;
                    case &quot;barchart&quot;: barVis.clearSelection(); break;
                    case &quot;geochart&quot;: geoVis.highlightItems(arrayIndices); break;
				}
				break;

		}
	
	};
    
    
    VISPANEL.clearCanvasAndShowMessage = function( message ){
        
        $( root ).empty();
			
		var messageOnCanvasDiv = d3.select( root ).append(&quot;div&quot;)
            .attr(&quot;id&quot;, &quot;eexcess_message_on_canvas&quot;);
			
		messageOnCanvasDiv.append(&quot;span&quot;)
            .text( message );	
			
        if( message == STR_LOADING ){
            messageOnCanvasDiv.append(&quot;img&quot;)
                .attr(&quot;src&quot;, LOADING_IMG);
        }
    };
            


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    var BOOKMARKS = {};


    BOOKMARKS.internal = {

        currentBookmark :{
                        &#x27;bookmark-name&#x27;: &#x27;&#x27;,
                        &#x27;color&#x27;: &#x27;&#x27;,
                        &#x27;type&#x27;: &#x27;&#x27;
                        },

        currentItem : {},


        getCurrentBookmark : function(){

            var bookmarkName = $(bookmarkDropdownList).find(&#x27;span&#x27;).text();
            var color = &#x27;&#x27;, type = &#x27;&#x27;;

            if( bookmarkName == STR_NEW ){
                bookmarkName = $(bookmarkDialogInputWrapper).find(&#x27;input&#x27;).val();
                color = $(colorPickerId).css(&#x27;backgroundColor&#x27;);
                type = &#x27;new&#x27;;
            }
            this.currentBookmark[&#x27;bookmark-name&#x27;] = bookmarkName;
            this.currentBookmark[&#x27;color&#x27;] = color;
            this.currentBookmark[&#x27;type&#x27;] = type;

            return this.currentBookmark;
        },


        setCurrentItem : function(item, index){
            //this.currentItem[&#x27;item&#x27;] = item;
            this.currentItem[&#x27;item&#x27;] = {
                &#x27;id&#x27;: item.id,
                &#x27;title&#x27;: item.title,
                &#x27;facets&#x27;: item.facets,
                &#x27;uri&#x27;: item.uri,
                &#x27;coordinate&#x27;: item.coordinate,
                &#x27;query&#x27;: query
            };
            this.currentItem[&#x27;index&#x27;] = index;
        },


        getCurrentItem : function(){ return this.currentItem[&#x27;item&#x27;]; },

        getCurrentItemIndex : function(){ return this.currentItem[&#x27;index&#x27;]; },

        validateBookmarkToSave : function(){
            var $message = $(newBookmarkOptionsId).find(&#x27;p&#x27;);

            // validation for new bookmark name
            if(
				(this.currentBookmark[&#x27;type&#x27;] == &#x27;new&#x27; &amp;&amp; this.currentBookmark[&#x27;bookmark-name&#x27;] == &#x27;&#x27;) ||
				this.currentBookmark[&#x27;bookmark-name&#x27;].length &gt; 15) {
                $message.fadeIn(&#x27;slow&#x27;);
                return false;
            }

            $message.fadeOut(&#x27;fast&#x27;);
            return true;
        }

    };



    BOOKMARKS.updateBookmarkedItems = function(){
        
		//bookmarkedItems = BookmarkingAPI.getBookmarkedItemsById(idsArray);
		//console.log(&#x27;bisher: &#x27;);
		//console.log(bookmarkedItems);
		 
		bookmarkedItems = {};
		var allBookmarks = BookmarkingAPI.getAllBookmarks();
		Object.keys(allBookmarks).forEach(function(bookmarkKey){
			allBookmarks[bookmarkKey].items.forEach(function(itemsElement){	
				
				var itemEntry = itemsElement[&#x27;id&#x27;];
				if(typeof bookmarkedItems[itemEntry] == &#x27;undefined&#x27; || bookmarkedItems[itemEntry] == &#x27;undefined&#x27;){
					bookmarkedItems[itemEntry] = { &#x27;bookmarked&#x27; : new Array() };
				}

				bookmarkedItems[itemEntry].bookmarked.push({
					&#x27;bookmark-name&#x27; : bookmarkKey,
					&#x27;bookmark-id&#x27; : allBookmarks[bookmarkKey].id,
					&#x27;color&#x27; : allBookmarks[bookmarkKey].color
				});
				
			});
		});
		
		//experimental code end to do ask cecillia ??
		//console.log(&#x27;neu: &#x27;);
		//console.log(bookmarkedItems);
		
        console.log(&#x27;----- BOOKMARKED ITEMS -----&#x27;);
        console.log(bookmarkedItems);
    };

    //BOOKMARKS.buildSaveBookmarkDialog = function(d, i, sender) {
	BOOKMARKS.buildSaveBookmarkDialog = function(datum, firstFunc,titleOutput,savebutton, sender) {

		$(filterBookmarkDialogId+&quot;&gt;div&quot;).removeClass(&quot;active&quot;).children(&quot;ul&quot;).slideUp(&#x27;slow&#x27;);

        BOOKMARKS.destroyBookmarkDialog();
        isBookmarkDialogOpen = true;

		firstFunc(this);
        //this.internal.setCurrentItem(d, i);

        var topOffset = $(contentPanel).offset().top;

        // Append bookmark form to content item
        var dialogBookmark = d3.select(&quot;body&quot;).append(&quot;div&quot;)
            .attr(&quot;id&quot;, &quot;eexcess-save-bookmark-dialog&quot;)
            .attr(&quot;class&quot;, &quot;eexcess-bookmark-dialog&quot;)
            .style(&#x27;display&#x27;, &#x27;none&#x27;)
            .style(&quot;top&quot;, topOffset + &quot;px&quot; );

        dialogBookmark.on(&#x27;click&#x27;, function(){ d3.event.stopPropagation(); });

        dialogBookmark.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;eexcess-bookmark-dialog-title&quot;)
            .text(&quot;Bookmark Item&quot;);

        // Append details section
        var bookmarkDetails = dialogBookmark.append(&#x27;div&#x27;)
            .attr(&#x27;class&#x27;, &#x27;eexcess-boookmark-dialog-details&#x27;);

        bookmarkDetails.append(&#x27;span&#x27;).attr(&#x27;class&#x27;, &#x27;label&#x27;).text(&#x27;Title:&#x27;);
        //bookmarkDetails.append(&#x27;p&#x27;).text(d.title);
		titleOutput(bookmarkDetails);
        //bookmarkDetails.append(&#x27;span&#x27;).text(&#x27;Query:&#x27;);
        //bookmarkDetails.append(&#x27;p&#x27;).text(query);

        // Append settings section (for bookmark selection or definition of new bookmark)
        var bookmarkSettings = dialogBookmark.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;eexcess-bookmark-dialog-settings&quot;);

        bookmarkSettings.append(&quot;span&quot;).attr(&#x27;class&#x27;, &#x27;label&#x27;).text(&quot;Add to:&quot;);

        // array to be sent to plugin building the dropdown list with the list items and the corresponding colors
        var optionsData = $.merge([{&#x27;bookmark-name&#x27;: STR_NEW, &#x27;color&#x27;: &#x27;&#x27;}], BookmarkingAPI.getAllBookmarkNamesAndColors());

        var bookmarksListContainer = bookmarkSettings.append(&quot;div&quot;).attr(&quot;class&quot;, &quot;eexcess-bookmark-dropdown-list&quot;)
            .append(&#x27;ul&#x27;);

        var bookmarksListData = bookmarksListContainer.selectAll(&#x27;li&#x27;).data(optionsData);

        bookmarksList = bookmarksListData.enter().append(&#x27;li&#x27;);
        bookmarksList.append(&#x27;a&#x27;).text(function(b){ return b[&quot;bookmark-name&quot;];});
        bookmarksList.append(&#x27;div&#x27;).text(function(b){ return b.color; });

        // Create dropdown list to select bookmark
        $( bookmarkDropdownList ).dropdown({
            &#x27;change&#x27; : EVTHANDLER.bookmarkDropdownListChanged
        });

        // Add wrapper div containing icon for color picking, text input and legendbookmarkDetails.append(&#x27;p&#x27;).text(d.title);
        var newBookmarkOptions = bookmarkSettings.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;eexcess-bookmark-dialog-optional&quot;);

        newBookmarkOptions.append(&quot;div&quot;)
            .attr(&quot;id&quot;, &quot;eexcess-bookmak-dialog-color-picker&quot;)
            .attr(&quot;title&quot;, &quot;Select Color&quot;);


        newBookmarkOptions.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;eexcess-bookmark-dialog-input-wrapper&quot;)
            .append(&quot;input&quot;);

        newBookmarkOptions.append(&#x27;p&#x27;)
            .text(STR_BOOKMARK_NAME_MISSING)
            .style(&#x27;display&#x27;, &#x27;none&#x27;);

        var bookmarkButtonsWrapper1 = dialogBookmark.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;eexcess-bookmark-buttons-wrapper&quot;);

        bookmarkButtonsWrapper1.append(&quot;input&quot;)
            .attr(&quot;type&quot;, &quot;button&quot;)
            .attr(&quot;class&quot;, &quot;eexcess-bookmark-button&quot;)
            .attr(&quot;style&quot;, &quot;width:65px;&quot;)
            .attr(&quot;value&quot;, &quot;Save new&quot;)
			.on(&quot;click&quot;,savebutton);
            //.on(&quot;click&quot;, EVTHANDLER.bookmarkSaveButtonClicked);


        // Also show delete - buttons in this dialog.
		// Todo: remove the old bookmark-info popup
        if (datum &amp;&amp; bookmarkedItems[datum.id]){
            //var bookmarkListToDelete = dialogBookmark.append(&quot;div&quot;)
            //    .attr(&quot;class&quot;, &quot;eexcess-bookmark-bookmarkList&quot;);

            var bookmarkedInSection = dialogBookmark.append(&#x27;div&#x27;).attr(&#x27;class&#x27;, &#x27;eexcess-bookmark-bookmarked-in-section&#x27;);
            bookmarkedInSection.append(&#x27;span&#x27;).attr(&#x27;class&#x27;, &#x27;label&#x27;).style(&#x27;width&#x27;, &#x27;100%&#x27;).text(&#x27;Already bookmarked in:&#x27;);

            var itemBookmarksData = bookmarkedInSection.selectAll(&#x27;div&#x27;)
                .data(bookmarkedItems[datum.id].bookmarked);

            var itemInBookmarks = itemBookmarksData.enter().append(&#x27;div&#x27;)
                    .attr(&#x27;class&#x27;, &#x27;eexcess-bookmark-bookmarked-in&#x27;);

            itemInBookmarks.append(&#x27;div&#x27;)
                .attr(&#x27;class&#x27;, &#x27;eexcess-bookmark-color-icon&#x27;)
                .style(&#x27;background-color&#x27;, function(d){ return d.color; });

            itemInBookmarks.append(&#x27;span&#x27;).text(function(d){ return d[&quot;bookmark-name&quot;]; });

            itemInBookmarks.append(&#x27;img&#x27;)
                .attr(&#x27;src&#x27;, REMOVE_SMALL_ICON)
                .attr(&#x27;title&#x27;, &#x27;Remove item from this bookmark&#x27;)
                .on(&#x27;click&#x27;, EVTHANDLER.removeBookmarkIconClicked);
        }





        // Append save and cancel buttons within container
        var bookmarkButtonsWrapper = dialogBookmark.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;eexcess-bookmark-buttons-wrapper&quot;);


        bookmarkButtonsWrapper.append(&quot;input&quot;)
            .attr(&quot;type&quot;, &quot;button&quot;)
            .attr(&quot;class&quot;, &quot;eexcess-bookmark-button&quot;)
            .attr(&quot;value&quot;, &quot;Close&quot;)
            .on(&#x27;click&#x27;, EVTHANDLER.bookmarkCancelButtonClicked);


        // show bookmark dialog
        $(saveBookmarkDialogId).slideDown(&#x27;slow&#x27;);

        // make div icon a color picker
        $( colorPickerId ).colorpicker({
            &#x27;img&#x27; : IMG_COLOR_WHEEL_LARGE,
            &#x27;width&#x27; : 200,
            &#x27;height&#x27; : 200
        });
		
		
    };




    BOOKMARKS.destroyBookmarkDialog = function(){
        $( colorPickerId ).colorpicker(&#x27;destroy&#x27;);
        $( bookmarkDialogClass ).remove();

        isBookmarkDialogOpen = false;
    };



    BOOKMARKS.saveBookmark = function(){

        var bookmark = this.internal.getCurrentBookmark();
        var item = this.internal.getCurrentItem();
        var index = this.internal.getCurrentItemIndex();

        if( this.internal.validateBookmarkToSave() ){
            if(bookmark[&#x27;type&#x27;] == &#x27;new&#x27;)
                BookmarkingAPI.createBookmark(bookmark[&#x27;bookmark-name&#x27;], bookmark[&#x27;color&#x27;]);

            console.log(BookmarkingAPI.addItemToBookmark(bookmark[&#x27;bookmark-name&#x27;], item));

            BOOKMARKS.destroyBookmarkDialog();
            LIST.turnFaviconOnAndShowDetailsIcon(index);

            // Update ancillary variable
            BOOKMARKS.updateBookmarkedItems();
        }
    };

	


    BOOKMARKS.buildSeeAndEditBookmarkDialog = function( datum, index ){

        BOOKMARKS.destroyBookmarkDialog();
        isBookmarkDialogOpen = true;

        this.internal.setCurrentItem(datum, index);

        var topOffset = $(contentPanel).offset().top;

        var detailsDialog = d3.select(&#x27;body&#x27;).append(&#x27;div&#x27;)
            .attr(&#x27;id&#x27;, &#x27;eexcess-see-and-edit-bookmark-dialog&#x27;)
            .attr(&quot;class&quot;, &quot;eexcess-bookmark-dialog&quot;)
            .style(&#x27;top&#x27;, topOffset + &#x27;px&#x27;)
            .style(&#x27;display&#x27;, &#x27;none&#x27;)
            .on(&quot;click&quot;, function(){ d3.event.stopPropagation(); });

        detailsDialog.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;eexcess-bookmark-dialog-title&quot;)
            .text(&#x27;Bookmark Info&#x27;);        // = datum.tilte

        var detailsSection = detailsDialog.append(&#x27;div&#x27;)
            .attr(&#x27;class&#x27;, &#x27;eexcess-boookmark-dialog-details&#x27;);

        detailsSection.append(&#x27;span&#x27;).text(&#x27;Title&#x27;);
        detailsSection.append(&#x27;p&#x27;).text(datum.title);


        var bookmarkedInSection = detailsDialog.append(&#x27;div&#x27;).attr(&#x27;class&#x27;, &#x27;eexcess-bookmark-bookmarked-in-section&#x27;);
        bookmarkedInSection.append(&#x27;span&#x27;).style(&#x27;width&#x27;, &#x27;100%&#x27;).text(&#x27;Bookmarked in:&#x27;);

        var itemBookmarksData = bookmarkedInSection.selectAll(&#x27;div&#x27;)
            .data(bookmarkedItems[datum.id].bookmarked);

        var itemInBookmarks = itemBookmarksData.enter().append(&#x27;div&#x27;)
                //.attr(&#x27;id&#x27;, function(d, i){ return &#x27;eexcess-bookmark-bookmarked-in-&#x27; + i; })
                .attr(&#x27;class&#x27;, &#x27;eexcess-bookmark-bookmarked-in&#x27;);

        itemInBookmarks.append(&#x27;div&#x27;)
            .attr(&#x27;class&#x27;, &#x27;eexcess-bookmark-color-icon&#x27;)
            .style(&#x27;background-color&#x27;, function(d){ return d.color; });

        itemInBookmarks.append(&#x27;span&#x27;).text(function(d){ return d[&quot;bookmark-name&quot;]; });

        itemInBookmarks.append(&#x27;img&#x27;)
            .attr(&#x27;src&#x27;, REMOVE_SMALL_ICON)
            .attr(&#x27;title&#x27;, &#x27;Remove item from this bookmark&#x27;)
            .on(&#x27;click&#x27;, EVTHANDLER.removeBookmarkIconClicked);


        // Append done button within container
        var bookmarkButtonsWrapper = detailsDialog.append(&quot;div&quot;)
            .attr(&quot;class&quot;, &quot;eexcess-bookmark-buttons-wrapper&quot;);

        bookmarkButtonsWrapper.append(&quot;input&quot;)
            .attr(&quot;type&quot;, &quot;button&quot;)
            .attr(&quot;class&quot;, &quot;eexcess-bookmark-button&quot;)
            .attr(&quot;value&quot;, &quot;Done&quot;)
            .on(&quot;click&quot;, EVTHANDLER.bookmarkDoneButtonClicked);

        $(detailsBookmarkDialogId).slideDown(&#x27;slow&#x27;);
    };
	


    BOOKMARKS.deleteBookmarkAndRefreshDetailsDialog = function(sender, bookmark, bookmarkIndex){

        var itemId = this.internal.getCurrentItem().id;
        var itemIndex = this.internal.getCurrentItemIndex();
        
        BookmarkingAPI.deleteItemFromBookmark(itemId, bookmark[&quot;bookmark-name&quot;]);

        // sender is img element with remove icon
        $(sender.parentNode).remove();
		
		
		BOOKMARKS.updateBookmarkedItems();

        if(typeof bookmarkedItems[itemId] == &#x27;undefined&#x27; || bookmarkedItems[itemId] == &#x27;undefined&#x27;)
            LIST.turnFaviconOffAndHideDetailsIcon(itemIndex);
			
		FILTER.changeDropDownList();
		
		//update list and drop down list
		$(filterBookmarkDialogId+&quot;&gt;div&gt;ul&gt;li:eq(&quot;+currentSelectIndexPerFilter+&quot;)&quot;).trigger(&quot;click&quot;);

		$(filterBookmarkDialogId+&quot;&gt;div&gt;ul&quot;).css(&quot;display&quot;,&quot;none&quot;);
		$(filterBookmarkDialogId+&quot;&gt;div&quot;).removeClass(&quot;active&quot;);
		//update list and drop down list
		
    };
	
	
	BOOKMARKS.exportBookmarks = function(){

		window.URL = window.URL;// || window.webkitURL;

		console.log(BookmarkingAPI.getAllBookmarks());


		$(exportBookmark).on(&quot;click&quot;,function(evt){

			var bookmarkData = JSON.stringify(BookmarkingAPI.getAllBookmarks());
			var blob = new Blob([bookmarkData], {type: &#x27;text/plain&#x27;});
			$(exportBookmark).attr(&quot;href&quot;, window.URL.createObjectURL(blob));
			$(exportBookmark).attr(&quot;download&quot;, &quot;bookmarks.txt&quot;);
		});
		//$(exportBookmark).attr(&quot;href&quot;, window.URL.createObjectURL(blob));
		//$(exportBookmark).attr(&quot;download&quot;, &quot;bookmarks.txt&quot;);
		
		
		

	};

	BOOKMARKS.importBookmarks = function(){
		function doOpen(evt,func) {
			var files = evt.target.files;
			var reader = new FileReader();
			reader.onload = function() {
				func(this.result);
			};
			reader.readAsText(files[0]);
		}
		
		$(importBookmarkStyle).on(&quot;click&quot;,function(evt){
			$(importBookmark).trigger(&quot;click&quot;);
		});

		$(importBookmark).on(&quot;change&quot;,function(evt){
			doOpen(evt,function(dataString){
			
				//update control
				FILTER.changeDropDownList();
				
				FILTER.showStars();
				FILTER.updateData();
				FILTER.showStars();
				FILTER.updateData();
			
			
				var importBookmarks = JSON.parse(dataString);
				console.log(importBookmarks);
				var allBookmarks = BookmarkingAPI.getAllBookmarks();
				console.log(allBookmarks);
				
				//compare items id&#x27;s
				function searchItemId(items,searchedId){
					items.forEach(function(item){
						if(item.id == searchedId){
							return true;
						}
					});
					return false;
				}
				
				//compare and create bookmark items
				function importItems(bookmark){
					importBookmarks[bookmark].items.forEach(function(currentItem){
						if(!searchItemId(allBookmarks[bookmark].items,currentItem.id)){
							BookmarkingAPI.addItemToBookmark(bookmark,currentItem);
						}
					});
				}
				
				//compare and create two bookmarks
				Object.keys(importBookmarks).forEach(function(currentBookmark){
					if(allBookmarks.hasOwnProperty(currentBookmark)){
						importItems(currentBookmark);
					}else{
						BookmarkingAPI.createBookmark(currentBookmark,importBookmarks[currentBookmark].color);
						importItems(currentBookmark);
					}
				});
				

			});
			
			FILTER.showStars();
			FILTER.updateData();
			FILTER.showStars();
			FILTER.updateData();
			
		});
	
	};


	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	///////////// External calls to allow overloaded visualization communicate with the template


    var EXT = {};
	
		
	EXT.ListItemSelected = function(datum, index){
		LIST.selectListItem( datum, index, true );
	};
	
	
	EXT.selectItems = function( itemIndicesArray ){
		LIST.highlightListItems( itemIndicesArray, true );
	};

	EXT.getAllSelectListItems = function(){
		return VISPANEL.getAllSelectListItems();
	};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    var FILTER = {};

	var currentSelectIndex = 0;
	var currentSelectIndexPerFilter = 0;

	//change new Bookmarks
	FILTER.changeDropDownList = function(){
	
		$( filterBookmarkDialogId ).remove();
		
		var topOffset = $(filterSelect).offset().top;
		var dialogBookmark = d3.select(filterSelect+&quot;&gt;span&quot;).append(&quot;span&quot;)//div
			.attr(&quot;id&quot;, &quot;eexcess-filter-bookmark-dialog&quot;)
			.attr(&quot;class&quot;, &quot;eexcess-filter-bookmark-dialog&quot;)
			.style(&quot;top&quot;, topOffset + &quot;px&quot; )
			.style(&quot;width&quot;,&quot;200px&quot;);
		
		var bookmarksListContainer = dialogBookmark.append(&quot;div&quot;)
			.attr(&quot;class&quot;, &quot;eexcess-bookmark-dropdown-list&quot;)
			.append(&#x27;ul&#x27;);

		var bookmarks = BookmarkingAPI.getAllBookmarkNamesAndColors();
		
		var bookmarkCount = 0;
		bookmarks.forEach(function(elementData,indexData){
			bookmarkCount = 0;
			bookmarkCount = BookmarkingAPI.getAllBookmarks()[elementData[&quot;bookmark-name&quot;]].items.length;
			elementData[&quot;bookmark-name&quot;] = elementData[&quot;bookmark-name&quot;] + &quot; : (&quot;+bookmarkCount+&quot;)&quot;;
		});

	    var optionsData =  $.merge([{&#x27;bookmark-name&#x27;: STR_SHOWALLRESULTS, &#x27;color&#x27;: &#x27;&#x27;}], 
			bookmarks
		);
		
		var bookmarksListData = bookmarksListContainer.selectAll(&#x27;li&#x27;).data(optionsData);

        var bookmarksList = bookmarksListData.enter().append(&#x27;li&#x27;);
        bookmarksList.append(&#x27;a&#x27;).text(function(b){ return b[&quot;bookmark-name&quot;];})
        bookmarksList.append(&#x27;div&#x27;).text(function(b){ return b.color; });
		
        $(filterBookmarkDropdownList).dropdown({
		   &#x27;change&#x27;:function(evt,index){
				currentSelectIndexPerFilter = index;

				
				evt = evt.split(&quot;:&quot;)[0].trim();
				var input ={};
				indicesToHighlight =[];

				if(evt == STR_SHOWALLRESULTS){
				
					FILTER.showStars();
					FILTER.updateData();
					
					$(deleteBookmark).prop(&quot;disabled&quot;,true);
				}else{
					//filtered bookmark from data
					var currentBookmarkItems = BookmarkingAPI.getAllBookmarks()[evt].items;

					//FILTER.filterBookmark(inputData,currentBookmarkItems,function(inputData,indexData){
					//	input.data.push(inputData[indexData]);
					//});
					
					input.data = [];
					var bookmarkCount = 0;
					currentBookmarkItems.forEach(function(item){
						input.data.push(item);
						indicesToHighlight.push(++bookmarkCount);
					});
					data = input.data;
					
					FILTER.updateData();
					$(deleteBookmark).prop(&quot;disabled&quot;,false).css(&quot;background&quot;,&quot;&quot;);
				}
		   }
        });
		
		$(filterBookmarkDialogId).on(&quot;mousedown&quot;,function(evt){
			BOOKMARKS.destroyBookmarkDialog();
			isBookmarkDialogOpen = false;	
		});
		
		$(filterBookmarkDialogId).slideDown(&#x27;slow&#x27;);
	};
	
	/*
	FILTER.filterBookmark = function(inputDataParam,currentBookmark,func){
		inputDataParam.forEach(function(elementData,indexData){
			currentBookmark.forEach(function(elementBookmark,indexBookmark){
				if(elementData.id == elementBookmark.id){
					func(inputDataParam,indexData);
				}
			});
		});
	}
	*/
	
	// build filter bookmark and delete bookmark control.
	FILTER.buildFilterBookmark = function(){
	
	    BOOKMARKS.destroyBookmarkDialog();
		inputData=data;

		FILTER.changeDropDownList();
		
		d3.select(addBookmarkItems).on(&quot;click&quot;, FILTER.buildAddBookmarkItems);
		
		d3.select(deleteBookmark).on(&quot;click&quot;,function(){

			if (confirm(&quot;Delete current bookmark?&quot;) == true) {
				var bookmarkName = $(filterBookmarkDialogId+&quot;&gt;div&gt;span&quot;).text().split(&quot;:&quot;)[0].trim();
				BookmarkingAPI.deleteBookmark(bookmarkName);
				
				FILTER.changeDropDownList();
				
				FILTER.showStars();
				FILTER.updateData();
				FILTER.showStars();
				FILTER.updateData();
			} 

		});
		$(deleteBookmark).prop(&quot;disabled&quot;,true);
	};
	
	FILTER.showStars = function(){
		var input ={};
		input.data = [];
		input.data = inputData;
		// update bookmarking changes:
		input.data.forEach(function(dataItem){
			if(typeof bookmarkedItems[dataItem.id] != &#x27;undefined&#x27; &amp;&amp;
				bookmarkedItems[dataItem.id] != &#x27;undefined&#x27;){
				dataItem[&#x27;bookmarked&#x27;] = true;
			}else{
				dataItem[&#x27;bookmarked&#x27;] = false;
			}	
		});
		data = input.data;	
		
		//FILTER.updateData();
	};
	
	FILTER.updateData = function(){
		// Initialize template&#x27;s elements
		//PREPROCESSING.setAncillaryVariables();
		BOOKMARKS.updateBookmarkedItems();
		//PREPROCESSING.extendDataWithAncillaryDetails();
		QUERY.updateHeaderText( &quot;Query Results : &quot; + data.length );
		QUERY.updateSearchField( query );
		//CONTROLS.buildChartSelect();
		LIST.buildContentList();
		VISPANEL.drawChart();
	};
	
	
	

	FILTER.buildAddBookmarkItems = function(d, i){
//BookmarkingAPI.deleteBookmark(&quot;&quot;);
        d3.event.stopPropagation();
		BOOKMARKS.buildSaveBookmarkDialog(
            d,
			function(thisValue){},
			function(bookmarkDetails){
				bookmarkDetails.append(&#x27;p&#x27;).text(&quot;selected bookmarks items&quot;);
			},function(){

				FILTER.addBookmarkItems();

				//$(filterBookmarkDialogId+&quot;&gt;div&gt;ul&gt;li:eq(&quot;+currentSelectIndex+&quot;)&quot;).trigger(&quot;click&quot;);
				var bookmark = BOOKMARKS.internal.getCurrentBookmark();
				if(bookmark[&#x27;type&#x27;] == &#x27;new&#x27; || bookmark[&#x27;type&#x27;] == &#x27;&#x27;){
					$(filterBookmarkDialogId+&quot;&gt;div&gt;ul&gt;li:eq(&quot;+
						BookmarkingAPI.getAllBookmarkNamesAndColors().length
					+&quot;)&quot;).trigger(&quot;click&quot;);
				}else{
					$(filterBookmarkDialogId+&quot;&gt;div&gt;ul&gt;li:eq(&quot;+currentSelectIndex+&quot;)&quot;).trigger(&quot;click&quot;);
				}
				
				$(filterBookmarkDialogId+&quot;&gt;div&gt;ul&quot;).css(&quot;display&quot;,&quot;none&quot;);
				$(filterBookmarkDialogId+&quot;&gt;div&quot;).removeClass(&quot;active&quot;);

				
			},
			this
		);
	};

	
	
	FILTER.addBookmarkItems = function(){
		//console.log(indicesToHighlight);
		var bookmark = BOOKMARKS.internal.getCurrentBookmark();
		
		if( BOOKMARKS.internal.validateBookmarkToSave() ){
		
			//var bookmark = BOOKMARKS.internal.getCurrentBookmark();
			if(bookmark[&#x27;type&#x27;] == &#x27;new&#x27;){
				BookmarkingAPI.createBookmark(bookmark[&#x27;bookmark-name&#x27;], bookmark[&#x27;color&#x27;]);
			}	

			function addBookmarkFunc(currentData,index){
				var bookmarkItem = {
					&#x27;id&#x27;: currentData.id,
					&#x27;title&#x27;: currentData.title,
					&#x27;facets&#x27;: currentData.facets,
					&#x27;uri&#x27;: currentData.uri,
					&#x27;coordinate&#x27;: currentData.coordinate,
					&#x27;query&#x27;: query
				};
				BookmarkingAPI.addItemToBookmark(bookmark[&#x27;bookmark-name&#x27;], bookmarkItem);
				LIST.turnFaviconOnAndShowDetailsIcon(index);
			}
			
			if(indicesToHighlight.length &gt; 0){
				var currentData;
				indicesToHighlight.forEach(function(indexValue){
					//console.log(indexValue);
					//console.log(data[indexValue]);
					
					currentData = data[indexValue];
					addBookmarkFunc(currentData,indexValue);
				});
			}
			
			BOOKMARKS.destroyBookmarkDialog();
			FILTER.changeDropDownList();
			
			FILTER.showStars();
			FILTER.updateData();
			FILTER.showStars();
			FILTER.updateData();

		}
	};

    return START;
}


	
	


    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
